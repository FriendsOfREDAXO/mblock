/**
 * MBlock Modular Build Script
 *
 * Combines modular source files into a single mblock.js file
 * Then minifies it for production use
 *
 * Usage: node build-modules.js
 *
 * @author MBlock Development Team
 * @version 1.0.0
 */

const fs = require('fs');
const path = require('path');

// Configuration
const sourceDir = path.join(__dirname, 'src');
const outputDir = path.join(__dirname, '..', 'assets');
const modules = [
    'mblock-core.js',
    'mblock-management.js',
    'mblock-features.js'
];

const combinedFile = path.join(outputDir, 'mblock.js');
const headerComment = `/**
 * MBlock Combined - Generated from modular sources
 *
 * Build Date: ${new Date().toISOString()}
 * Source Files: ${modules.join(' + ')}
 *
 * This file is automatically generated. Do not edit manually!
 * Edit the individual modular files instead.
 */

// ==================== MBLOCK CORE MODULE ====================
// ================== MBLOCK MANAGEMENT MODULE ================
// ================== MBLOCK FEATURES MODULE ==================
`;

/**
 * Main build function
 */
async function buildModules(debugMode = false) {
    try {
        console.log(`üîÑ MBlock Modular Build gestartet${debugMode ? ' (Debug-Modus)' : ''}...\n`);

        // Check if source directory exists
        if (!fs.existsSync(sourceDir)) {
            throw new Error(`Source directory nicht gefunden: ${sourceDir}`);
        }

        // Check if all modules exist
        for (const module of modules) {
            const modulePath = path.join(sourceDir, module);
            if (!fs.existsSync(modulePath)) {
                throw new Error(`Modul nicht gefunden: ${module}`);
            }
        }

        console.log('‚úÖ Alle Module gefunden');

        // Preprocess modules for production (remove console.log statements) unless in debug mode
        if (!debugMode) {
            console.log('üîß Preprocessing f√ºr Produktion...');
            const { preprocess } = require('./preprocess.js');
            preprocess();
        } else {
            console.log('üêõ Debug-Modus: Console.log Statements bleiben erhalten');
        }

        // Read and combine modules
        let combinedContent = headerComment;

        for (const module of modules) {
            const modulePath = path.join(sourceDir, module);
            console.log(`üìñ Lese Modul: ${module}`);

            const moduleContent = fs.readFileSync(modulePath, 'utf8');

            // Add module separator comment
            const separator = `\n\n// ==================== ${module.replace(/\.js$/i, ' MODULE').toUpperCase()} ====================\n`;
            combinedContent += separator + moduleContent;
        }

        // Ensure output directory exists
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Write combined file
        fs.writeFileSync(combinedFile, combinedContent, 'utf8');

        const stats = fs.statSync(combinedFile);
        const fileSize = (stats.size / 1024).toFixed(2);

        console.log(`\nüíæ Kombinierte Datei erstellt: ${combinedFile}`);
        console.log(`üìè Dateigr√∂√üe: ${fileSize} KB`);
        console.log('\n‚úÖ Module erfolgreich kombiniert!');

        // Now run minification
        console.log('\n‚öôÔ∏è  Starte Minifizierung...');
        const { minifyMBlock } = require('./minify.js');
        await minifyMBlock();

        console.log('\nüéâ MBlock Modular Build erfolgreich abgeschlossen!');

    } catch (error) {
        console.error('‚ùå Fehler beim Build:', error.message);
        process.exit(1);
    }
}

/**
 * Clean build artifacts
 */
function clean() {
    try {
        if (fs.existsSync(combinedFile)) {
            fs.unlinkSync(combinedFile);
            console.log('üßπ Kombinierte Datei gel√∂scht');
        }

        const minifiedFile = path.join(outputDir, 'mblock.min.js');
        const mapFile = path.join(outputDir, 'mblock.min.js.map');

        if (fs.existsSync(minifiedFile)) {
            fs.unlinkSync(minifiedFile);
            console.log('üßπ Minifizierte Datei gel√∂scht');
        }

        if (fs.existsSync(mapFile)) {
            fs.unlinkSync(mapFile);
            console.log('üßπ Source Map gel√∂scht');
        }

    } catch (error) {
        console.error('‚ùå Fehler beim Aufr√§umen:', error.message);
    }
}

/**
 * Watch mode for development
 */
function watch() {
    console.log('üëÄ Watch mode aktiviert - √úberwache Modul-√Ñnderungen...');

    const chokidar = require('chokidar');

    const watcher = chokidar.watch(sourceDir, {
        ignored: /(^|[\/\\])\../,
        persistent: true
    });

    watcher.on('change', (filePath) => {
        console.log(`üìù √Ñnderung erkannt: ${path.basename(filePath)}`);
        buildModules();
    });

    console.log('Dr√ºcke Ctrl+C zum Beenden');
}

// Command line interface
const command = process.argv[2];

switch (command) {
    case 'clean':
        clean();
        break;
    case 'watch':
        buildModules(true).then(() => watch());
        break;
    case 'debug':
        buildModules(true).then(() => {
            console.log('\nüêõ Debug-Build abgeschlossen (mit console.log Statements)');
        });
        break;
    default:
        buildModules();
        break;
}

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { buildModules, clean };
}
