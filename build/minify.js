#!/usr/bin/env node

/**
 * MBlock JavaScript Minification Script
 * 
 * Minifies mblock.js using Terser for production use
 * Creates mblock.min.js with source maps
 * 
 * Usage: node minify.js
 * 
 * @author MBlock Development Team
 * @version 1.0.0
 */

const fs = require('fs');
const path = require('path');
const { minify } = require('terser');

// Configuration - Use combined mblock.js as source (generated by build-modules.js)
const sourceFile = '../assets/mblock.js';
const outputFile = '../assets/mblock.min.js';
const sourceMapFile = '../assets/mblock.min.js.map';

// Terser options for optimal minification
const terserOptions = {
    compress: {
        // Remove console.log statements but keep console.error/warn for debugging
        pure_funcs: ['console.log', 'console.debug', 'console.info'],
        drop_console: false, // Keep console.error/warn but remove others
        drop_debugger: true,
        passes: 1,
        unsafe_arrows: false,
        unsafe_methods: false,
        hoist_funs: false,
        hoist_vars: false,
        if_return: true,
        join_vars: false,
        collapse_vars: false,
        reduce_vars: false,
        warnings: false,
        negate_iife: true,
        pure_getters: false,
        keep_fargs: false,
        keep_fnames: false,
        keep_infinity: true,
        sequences: false,
        dead_code: true,
        conditionals: false,
        comparisons: false,
        evaluate: false,
        booleans: true,
        loops: true,
        unused: false,
        toplevel: false
    },
    mangle: {
        // Preserve specific function names that might be called externally
        reserved: [
            'mblock_init',
            'mblock_init_sort',
            'mblock_sort',
            'mblock_add',
            'MBlockClipboard',
            'MBlockOnlineToggle',
            'mblock_smooth_scroll_to_element',
            'mblock_show_message',
            'mblock_get_text',
            'mblock_validate_element',
            'MBlockUtils',
            'closest',
            'parents',
            'find',
            'addClass',
            'removeClass',
            '$this',
            '$targetItem',
            '$item',
            'jQuery',
            '$',
            'element',
            'item',
            'targetItem',
            'mblock_add_item',
            'mblock_remove_item',
            'mblock_moveup',
            'mblock_movedown'
        ],
        toplevel: false,
        eval: false,
        keep_fnames: true,
        safari10: true,
        properties: false // Disable property mangling completely
    },
    format: {
        comments: false, // Remove all comments
        semicolons: true,
        beautify: false,
        ascii_only: true,
        wrap_iife: true,
        indent_level: 0
    },
    sourceMap: {
        filename: path.basename(outputFile),
        url: path.basename(sourceMapFile),
        includeSources: false // Don't include source code in map for smaller size
    },
    toplevel: true,
    ie8: false,
    safari10: true,
    keep_classnames: false,
    keep_fnames: false,
    module: false
};

/**
 * Main minification function
 */
async function minifyMBlock() {
    try {
        console.log('üîÑ MBlock JavaScript Minification gestartet...\n');
        
        // Read source file
        const sourceFilePath = path.resolve(__dirname, sourceFile);
        console.log(`üìñ Lese Quelldatei: ${sourceFilePath}`);
        
        if (!fs.existsSync(sourceFilePath)) {
            throw new Error(`Quelldatei nicht gefunden: ${sourceFilePath}`);
        }
        
        const sourceCode = fs.readFileSync(sourceFilePath, 'utf8');
        const originalSize = Buffer.byteLength(sourceCode, 'utf8');
        console.log(`üìè Originalgr√∂√üe: ${formatBytes(originalSize)}`);
        
        // Perform minification
        console.log('‚öôÔ∏è  Minification wird durchgef√ºhrt...');
        const startTime = Date.now();
        
        const result = await minify(sourceCode, terserOptions);
        
        if (result.error) {
            throw new Error(`Minification Fehler: ${result.error}`);
        }
        
        const endTime = Date.now();
        const minifiedSize = Buffer.byteLength(result.code, 'utf8');
        
        // Write minified file
        const outputFilePath = path.resolve(__dirname, outputFile);
        fs.writeFileSync(outputFilePath, result.code, 'utf8');
        console.log(`üíæ Minified Datei erstellt: ${outputFilePath}`);
        
        // Write source map
        if (result.map) {
            const sourceMapFilePath = path.resolve(__dirname, sourceMapFile);
            fs.writeFileSync(sourceMapFilePath, result.map, 'utf8');
            console.log(`üó∫Ô∏è  Source Map erstellt: ${sourceMapFilePath}`);
        }
        
        // Statistics
        const compressionRatio = ((originalSize - minifiedSize) / originalSize * 100);
        
        console.log('\nüìä Minification Statistiken:');
        console.log('‚îÄ'.repeat(40));
        console.log(`üìè Originalgr√∂√üe:     ${formatBytes(originalSize)}`);
        console.log(`üóúÔ∏è  Minified Gr√∂√üe:   ${formatBytes(minifiedSize)}`);
        console.log(`üíæ Ersparnis:         ${formatBytes(originalSize - minifiedSize)} (${compressionRatio.toFixed(2)}%)`);
        console.log(`‚è±Ô∏è  Verarbeitungszeit: ${endTime - startTime}ms`);
        console.log('‚îÄ'.repeat(40));
        
        console.log('\n‚úÖ MBlock JavaScript erfolgreich minified!');
        console.log(`\nüí° Tipp: Verwende 'mblock.min.js' in der Produktion f√ºr bessere Performance`);
        
    } catch (error) {
        console.error('‚ùå Fehler bei der Minification:');
        console.error(error.message);
        process.exit(1);
    }
}

/**
 * Format bytes to human readable format
 */
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Check if terser is available
 */
function checkDependencies() {
    try {
        require('terser');
        return true;
    } catch (error) {
        console.error('‚ùå Terser ist nicht installiert!');
        console.log('üí° Installiere es mit: npm install terser');
        return false;
    }
}

// Run minification if called directly
if (require.main === module) {
    if (checkDependencies()) {
        minifyMBlock();
    } else {
        process.exit(1);
    }
}

// Export the main function and configuration
module.exports = {
    minifyMBlock,
    sourceFile,
    outputFile,
    sourceMapFile,
    terserOptions
};

// Also export the function directly for easier importing
module.exports.minifyMBlock = minifyMBlock;
