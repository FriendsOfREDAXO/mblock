/**
 * MBlock Combined - Generated from modular sources
 *
 * Build Date: 2025-09-16T21:12:57.025Z
 * Source Files: mblock-core.js + mblock-management.js + mblock-features.js
 *
 * This file is automatically generated. Do not edit manually!
 * Edit the individual modular files instead.
 */

// ==================== MBLOCK CORE MODULE ====================
// ================== MBLOCK MANAGEMENT MODULE ================
// ================== MBLOCK FEATURES MODULE ==================


// ==================== MBLOCK-CORE MODULE ====================
/**
 * MBlock Core - Base functionality and utilities
 * 
 * Contains:
 * - Core utilities (MBlockUtils)
 * - Basic validation and helper functions
 * - Message handling
 * - Translation functions
 * - Element validation
 * 
 * @author joachim doerr
 * @version 2.0
 */

let mblock = '.mblock_wrapper';

// üîß Central Utility Object - Reduces redundancy and provides reusable functions
const MBlockUtils = {
    // Cached selectors for better performance
    selectors: {
        wrapper: '.mblock_wrapper',
        sortitem: '> div.sortitem',
        addme: '.addme',
        removeme: '.removeme',
        moveup: '.moveup',
        movedown: '.movedown',
        copyBtn: '.mblock-copy-btn',
        pasteBtn: '.mblock-paste-btn',
        onlineToggle: '.mblock-online-toggle',
        autoToggle: '.mblock-offline-toggle-btn'
    },

    // DOM manipulation helpers
    dom: {
        findElement(container, selector) {
            return container?.find ? container.find(selector) : $(selector);
        },

        safeRemove(element) {
            if (element?.length) {
                element.find('*').off('.mblock');
                element.off('.mblock');
                element.remove();
                return true;
            }
            return false;
        },

        createFromHTML(html) {
            return $($.parseHTML(html));
        }
    },

    // Event handling utilities
    events: {
        bindSafe(element, event, handler, namespace = '.mblock') {
            if (element?.length) {
                element.off(event + namespace).on(event + namespace, handler);
            }
        },

        cleanup(element, namespace = '.mblock') {
            if (mblock_validate_element(element) && element.jquery) {
                element.find('*').off(namespace);
                element.off(namespace);
            }
        }
    },

    // State management
    state: {
        isDisabled(element) {
            return element.prop('disabled') || element.hasClass('disabled');
        },

        toggleDisabled(element, disabled) {
            element.prop('disabled', disabled);
            element.toggleClass('disabled', disabled);
        }
    },

    // Nested MBlock utilities for GridBlock compatibility
    nested: {
        /**
         * Clean up duplicate elements in nested MBlocks
         * @param {jQuery} container - Container to clean
         */
        cleanupDuplicates(container) {
            try {
                if (!container || !container.length) return;
                
                container.find('.mblock_wrapper').each(function() {
                    const $nestedWrapper = $(this);
                    // Remove duplicate initialization
                    if ($nestedWrapper.data('mblock_initialized')) {
                        $nestedWrapper.removeData('mblock_initialized');
                    }
                });
            } catch (error) {
                console.error('MBlock: Error cleaning up nested duplicates:', error);
            }
        },

        /**
         * Initialize nested MBlocks safely
         * @param {jQuery} container - Container with nested MBlocks
         */
        initializeNested(container) {
            try {
                if (!container || !container.length) return;
                
                container.find('.mblock_wrapper').each(function() {
                    const $nestedWrapper = $(this);
                    if (!$nestedWrapper.data('mblock_initialized')) {
                        mblock_init($nestedWrapper);
                        $nestedWrapper.data('mblock_initialized', true);
                    }
                });
            } catch (error) {
                console.error('MBlock: Error initializing nested MBlocks:', error);
            }
        }
    },

    // Animation utilities
    animation: {
        addGlowEffect(element, className = 'mblock-copy-glow', duration = 1000) {
            if (element?.length) {
                element.addClass(className);
                setTimeout(() => element.removeClass(className), duration);
            }
        },

        flashEffect(element, className = 'mblock-dropped-flash', duration = 600) {
            if (element?.length) {
                element.addClass(className);
                setTimeout(() => element.removeClass(className), duration);
            }
        }
    },

    // Type checking utilities
    is: {
        validElement(element) {
            return mblock_validate_element(element);
        },

        rexField(id, type) {
            return id && id.indexOf(`REX_${type}_`) >= 0;
        },

        hiddenInput(element) {
            return element.attr('type') === 'hidden';
        }
    }
};

// üîß Helper function for improved error/warning feedback using bloecks
function mblock_show_message(message, type = 'warning', duration = 5000) {
    // Try to use bloecks toast system first with specific mblock method
    if (typeof BLOECKS !== 'undefined' && BLOECKS.fireMBlockToast) {
        BLOECKS.fireMBlockToast(message, type, duration);
    } else if (typeof BLOECKS !== 'undefined' && BLOECKS.showToast) {
        // Fallback to general showToast method
        BLOECKS.showToast(message, type, duration);
    } else {
        // Use internal toast fallback if available
        if (typeof MBLOCK_TOAST !== 'undefined' && MBLOCK_TOAST.show) {
            MBLOCK_TOAST.show(message, type, duration);
        }

        // Fallback to console
        if (type === 'error' || type === 'danger') {
            console.error('MBlock:', message);
        } else {
            console.warn('MBlock:', message);
        }
    }
}

// Simple namespaced toast fallback used when BLOECKS toast isn't available
const MBLOCK_TOAST = (function () {
    let counter = 0;
    let container = null;

    function createContainer() {
        if (container) return container;
        container = document.createElement('div');
        container.className = 'mblock-toast-container';
        container.style.position = 'fixed';
        container.style.top = '20px';
        container.style.right = '20px';
        container.style.zIndex = 99999;
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.gap = '8px';
        document.body.appendChild(container);
        return container;
    }

    function show(message, type = 'info', duration = 4000) {
        try {
            const cont = createContainer();
            const id = 'mblock-toast-' + (++counter);
            const toast = document.createElement('div');
            toast.id = id;
            toast.className = 'mblock-toast mblock-toast-' + type;
            toast.style.minWidth = '180px';
            toast.style.maxWidth = '420px';
            toast.style.padding = '10px 14px';
            toast.style.borderRadius = '4px';
            toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
            toast.style.background = type === 'error' || type === 'danger' ? '#f8d7da' : (type === 'success' ? '#d4edda' : '#fff3cd');
            toast.style.color = '#222';
            toast.style.border = '1px solid rgba(0,0,0,0.06)';
            toast.style.fontSize = '13px';
            toast.innerText = message;
            cont.appendChild(toast);

            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(100%)';
                }
            }, Math.max(50, duration - 250));

            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, duration + 100);
            return id;
        } catch (e) {
            console.warn('MBlock: Toast fallback failed', e);
            return false;
        }
    }

    return { show };
})();

// üåç Helper function to get translated text for toast messages
function mblock_get_text(key, fallback = '') {
    // Primary: Use server-provided translations (via boot.php)
    if (typeof rex !== 'undefined' && rex.mblock_i18n && rex.mblock_i18n[key.replace('mblock_toast_', '')]) {
        return rex.mblock_i18n[key.replace('mblock_toast_', '')];
    }
    
    // Secondary: Try rex_i18n if available
    if (typeof rex !== 'undefined' && rex.i18n) {
        const text = rex.i18n.msg(key);
        return text !== key ? text : fallback; // Return fallback if key not found
    }
    
    // Fallback to simple translations if rex is not available
    const translations = {
        'mblock_toast_copy_success': {
            'de': 'Block erfolgreich kopiert!',
            'en': 'Block copied successfully!',
            'es': '¬°Bloque copiado con √©xito!',
            'pt': 'Bloco copiado com sucesso!',
            'sv': 'Block kopierat framg√•ngsrikt!',
            'nl': 'Blok succesvol gekopieerd!'
        },
        'mblock_toast_paste_success': {
            'de': 'Block erfolgreich eingef√ºgt!',
            'en': 'Block pasted successfully!',
            'es': '¬°Bloque pegado con √©xito!',
            'pt': 'Bloco colado com sucesso!',
            'sv': 'Block inklistrat framg√•ngsrikt!',
            'nl': 'Blok succesvol geplakt!'
        },
        'mblock_toast_clipboard_empty': {
            'de': 'Keine Daten in der Zwischenablage',
            'en': 'No data in clipboard',
            'es': 'No hay datos en el portapapeles',
            'pt': 'Nenhum dado na √°rea de transfer√™ncia',
            'sv': 'Inga data i urklipp',
            'nl': 'Geen gegevens in klembord'
        },
        'mblock_toast_module_type_mismatch': {
            'de': 'Modultyp stimmt nicht √ºberein',
            'en': 'Module type mismatch',
            'es': 'No coincide el tipo de m√≥dulo',
            'pt': 'Tipo de m√≥dulo n√£o corresponde',
            'sv': 'Modultyp matchar inte',
            'nl': 'Moduletype komt niet overeen'
        }
    };
    
    // Get browser language or default to German
    const lang = (navigator.language || 'de').substring(0, 2);
    const langData = translations[key];
    
    if (langData && langData[lang]) {
        return langData[lang];
    } else if (langData && langData['de']) {
        return langData['de']; // Fallback to German
    }
    
    return fallback;
}

/**
 * Utility-Funktion zur sicheren jQuery-Element-Validierung
 * @param {jQuery|HTMLElement|string} element - Element zum Validieren
 * @returns {boolean} Ob Element g√ºltig ist
 */
function mblock_validate_element(element) {
    try {
        if (!element) return false;
        
        // jQuery-Objekt pr√ºfen
        if (element.jquery) {
            return element.length > 0 && typeof element.data === 'function';
        }
        
        // DOM-Element pr√ºfen
        if (element.nodeType) {
            return true;
        }
        
        // String-Selector pr√ºfen
        if (typeof element === 'string') {
            return element.length > 0;
        }
        
        return false;
    } catch (error) {
        console.error('MBlock: Fehler bei Element-Validierung:', error);
        return false;
    }
}

/**
 * Sichere Event-Cleanup-Funktion f√ºr besseres Memory-Management
 * @param {jQuery} element - Element dessen Events bereinigt werden sollen
 * @param {string} namespace - Event-Namespace (optional)
 */
function mblock_cleanup_events(element, namespace = '.mblock') {
    try {
        if (mblock_validate_element(element) && element.jquery) {
            // Alle Event-Listener mit Namespace entfernen
            element.find('*').off(namespace);
            element.off(namespace);
        }
    } catch (error) {
        console.error('MBlock: Fehler bei Event-Cleanup:', error);
    }
}

/**
 * Pr√ºft ob Copy/Paste in der Konfiguration aktiviert ist
 * @returns {boolean} True wenn aktiviert
 */
function checkCopyPasteEnabled() {
    try {
        // Method 1: Check data attribute on any mblock_wrapper
        const $wrapper = $(mblock).first();
        if ($wrapper.length) {
            const copyPasteAttr = $wrapper.attr('data-copy_paste');
            if (copyPasteAttr !== undefined) {
                return copyPasteAttr === 'true' || copyPasteAttr === '1';
            }
        }
        
        // Method 2: Check for presence of copy/paste buttons in DOM
        const hasCopyButtons = $('.mblock-copy-btn').length > 0;
        const hasToolbar = $('.mblock-copy-paste-toolbar').length > 0;
        
        return hasCopyButtons || hasToolbar;
        
    } catch (error) {
        console.warn('MBlock: Fehler beim Pr√ºfen der Copy/Paste-Konfiguration:', error);
        return true; // Default: aktiviert bei Fehlern
    }
}

// ‚ú® Modern Smooth Scroll - Use bloecks if available, fallback to vanilla
function mblock_smooth_scroll_to_element(element, options = {}) {
    if (!element) return;
    
    // Try to use bloecks smooth scroll system first
    if (typeof BLOECKS !== 'undefined' && typeof BLOECKS.scrollToSlice === 'function') {
        try {
            BLOECKS.scrollToSlice(element);
            return;
        } catch (error) {
            console.warn('MBlock: Bloecks scroll failed, using fallback:', error);
        }
    }
    
    const config = {
        behavior: 'smooth',
        block: 'center',
        inline: 'nearest',
        offset: -20, // Extra offset from top
        ...options
    };
    
    try {
        // Modern approach with scrollIntoView
        if ('scrollIntoView' in element) {
            // Calculate position with offset
            const elementRect = element.getBoundingClientRect();
            const absoluteElementTop = elementRect.top + window.pageYOffset;
            const scrollToPosition = absoluteElementTop + config.offset;
            
            // Smooth scroll to calculated position
            window.scrollTo({
                top: Math.max(0, scrollToPosition),
                behavior: config.behavior
            });
        } else {
            // Fallback for very old browsers
            element.scrollIntoView(config);
        }
    } catch (error) {
        // Ultimate fallback
        try {
            element.scrollIntoView();
        } catch (fallbackError) {
            console.warn('MBlock: Scroll fallback failed:', fallbackError);
        }
    }
}

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockUtils, mblock_show_message, mblock_get_text, mblock_validate_element };
}

// ==================== MBLOCK-MANAGEMENT MODULE ====================
/**
 * MBlock Management - DOM manipulation and sortable handling
 * 
 * Contains:
 * - Sortable management (MBlockSortable)
 * - Item manipulation (add, remove, move)
 * - Reindexing and form element handling
 * - REX field handling
 * - Toolbar functionality
 * 
 * Depends on: mblock-core.js
 * 
 * @author joachim doerr
 * @version 2.0
 */

// üîß Reusable Sortable Management
const MBlockSortable = {
    /**
     * Safely destroy existing sortable instance
     */
    destroy(element) {
        try {
            if (element && element.length && element.data('sortable')) {
                element.sortable('destroy');
                element.removeData('sortable');
                return true;
            }
        } catch (error) {
            console.warn('MBlock: Error destroying sortable:', error);
        }
        return false;
    },

    /**
     * Create new sortable instance with unified configuration
     */
    create(element) {
        try {
            if (!element || !element.length) return false;

            // Destroy existing instance first
            this.destroy(element);

            const sortableOptions = {
                handle: '.mblock-handle',
                placeholder: 'mblock-sortable-placeholder',
                tolerance: 'pointer',
                cursor: 'move',
                axis: 'y',
                containment: 'parent',
                start: this._handleStart,
                stop: (evt, ui) => this._handleEnd(evt, element),
                update: (evt, ui) => this._handleUpdate(evt, element)
            };

            element.sortable(sortableOptions);
            element.data('sortable', true);
            return true;
        } catch (error) {
            console.error('MBlock: Error creating sortable:', error);
            return false;
        }
    },

    /**
     * Reinitialize sortable (destroy + create with safety delay)
     */
    reinitialize(element) {
        this.destroy(element);
        setTimeout(() => this.create(element), 10);
    },

    // Private event handlers
    _handleStart(evt) {
        try {
            const $item = $(evt.target);
            $item.addClass('mblock-dragging');
        } catch (error) {
            console.warn('MBlock: Error in sort start handler:', error);
        }
    },

    _handleEnd(evt, element) {
        try {
            const $item = $(evt.target);
            $item.removeClass('mblock-dragging');
            mblock_reindex(element);
        } catch (error) {
            console.warn('MBlock: Error in sort end handler:', error);
        }
    },

    _handleUpdate(evt, element) {
        try {
            mblock_reindex(element);
            mblock_remove(element);
        } catch (error) {
            console.warn('MBlock: Error in sort update handler:', error);
        }
    }
};

// Core MBlock functions
$(document).on('rex:ready', function (e, container) {
    try {
        // Initialize clipboard system only if copy/paste is enabled
        const isCopyPasteEnabled = checkCopyPasteEnabled();
        if (isCopyPasteEnabled && typeof MBlockClipboard !== 'undefined') {
            MBlockClipboard.init();
        }
        
        if (container && typeof container.find === 'function') {
            container.find('.mblock_wrapper').each(function() {
                mblock_init($(this));
            });
        } else {
            $('.mblock_wrapper').each(function() {
                mblock_init($(this));
            });
        }
    } catch (error) {
        console.error('MBlock: Fehler bei rex:ready:', error);
    }
});

function mblock_init(element) {
    try {
        if (!element || !element.length || typeof element.data !== 'function') {
            console.warn('MBlock: Invalid element passed to mblock_init');
            return false;
        }

        // Check if element is already initialized
        const isAlreadyInitialized = element.data('mblock_run');
        
        if (!isAlreadyInitialized) {
            element.data('mblock_run', true);
            mblock_init_sort(element);
        } else {
            console.log('MBlock: Element already initialized, skipping');
            return true;
        }
        
        mblock_add_plus(element);
        mblock_init_toolbar(element);
        
        // Initialize online/offline states if MBlockOnlineToggle is available
        if (typeof MBlockOnlineToggle !== 'undefined') {
            MBlockOnlineToggle.initializeStates(element);
        }
        
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_init:', error);
        return false;
    }
}

// List with handle
function mblock_init_sort(element) {
    try {
        if (!element || !element.length) {
            console.warn('MBlock: Invalid element passed to mblock_init_sort');
            return false;
        }
        // reindex
        mblock_reindex(element);
        // init
        mblock_sort(element);
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_init_sort:', error);
        return false;
    }
}

function mblock_sort(element) {
    try {
        if (!element || !element.length) {
            console.warn('MBlock: Invalid element passed to mblock_sort');
            return false;
        }
        // add linking
        mblock_add(element);
        // remove mblock_remove
        mblock_remove(element);
        // init sortable
        mblock_sort_it(element);
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_sort:', error);
        return false;
    }
}

function mblock_add_plus(element) {
    // Only add the "add" button if there are no sortitems AND no existing add button
    const hasSortItems = element.find('> div.sortitem').length > 0;
    const hasAddButton = element.find('> div.mblock-single-add').length > 0;
    
    if (!hasSortItems && !hasAddButton) {
        console.log('MBlock: Adding single-add button for empty wrapper');
        element.prepend($($.parseHTML(element.data('mblock-single-add'))));

        element.find('> div.mblock-single-add .addme').unbind().bind('click', function () {
            const $wrapper = $(this).closest('.mblock_wrapper');
            mblock_add_item($wrapper, false);
        });
    } else if (hasSortItems && hasAddButton) {
        element.find('> div.mblock-single-add').remove();
    }
}

function mblock_remove(element) {
    var finded = element.find('> div.sortitem');

    if (finded.length == 1) {
        finded.find('.removeme').prop('disabled', true);
        finded.find('.removeme').attr('data-disabled', true);
    } else {
        finded.find('.removeme').prop('disabled', false);
        finded.find('.removeme').attr('data-disabled', false);
    }

    // has data?
    if (element.data().hasOwnProperty('max')) {
        if (finded.length >= element.data('max')) {
            element.find('.addme').prop('disabled', true);
            element.find('.addme').attr('data-disabled', true);
        } else {
            element.find('.addme').prop('disabled', false);
            element.find('.addme').attr('data-disabled', false);
        }
    }

    if (element.data().hasOwnProperty('min')) {
        if (finded.length <= element.data('min')) {
            finded.find('.removeme').prop('disabled', true);
            finded.find('.removeme').attr('data-disabled', true);
        } else {
            finded.find('.removeme').prop('disabled', false);
            finded.find('.removeme').attr('data-disabled', false);
        }
    }

    finded.each(function (index) {
        // min removeme hide
        if ((index + 1) == element.data('min') && finded.length == element.data('min')) {
            $(this).find('.removeme').hide();
        }
        if (index == 0) {
            $(this).find('.moveup').prop('disabled', true);
        } else {
            $(this).find('.moveup').prop('disabled', false);
        }
        if ((index + 1) == finded.length) {
            $(this).find('.movedown').prop('disabled', true);
        } else {
            $(this).find('.movedown').prop('disabled', false);
        }
    });
}

function mblock_sort_it(element) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length || !element.get) {
            console.warn('MBlock: Invalid element passed to mblock_sort_it');
            return false;
        }

        const domElement = element.get(0);
        if (!document.contains(domElement)) {
            console.warn('MBlock: Element not in DOM, skipping sortable initialization');
            return false;
        }

        // Use centralized sortable management
        if (typeof Sortable !== 'undefined' && Sortable.create) {
            // Use SortableJS library if available
            const sortableInstance = Sortable.create(domElement, {
                handle: '.mblock-handle',
                animation: 150,
                ghostClass: 'mblock-sortable-ghost',
                chosenClass: 'mblock-sortable-chosen',
                dragClass: 'mblock-sortable-drag',
                onStart: function(evt) {
                    MBlockSortable._handleStart(evt);
                },
                onEnd: function(evt) {
                    MBlockSortable._handleEnd(evt, element);
                }
            });
            element.data('sortable-instance', sortableInstance);
        } else {
            // Fallback to jQuery UI sortable
            MBlockSortable.create(element);
        }
        
    } catch (error) {
        console.error('MBlock: Fehler in mblock_sort_it:', error);
        return false;
    }
}

function mblock_reindex(element) {
    try {
        if (!mblock_validate_element(element)) {
            console.warn('MBlock: Invalid element passed to mblock_reindex');
            return false;
        }

        const mblock_count = element.data('mblock_count') || 0;
        const sortItems = element.find('> div.sortitem');
        
        if (!sortItems.length) {
            console.log('MBlock: No sortitems found, skipping reindex');
            return true;
        }

        // Performance-Optimierung: Batch DOM-Updates
        sortItems.each(function (index) {
            const $sortItem = $(this);
            const sindex = index + 1;
            
            // Update data attributes
            $sortItem.attr('data-mblock_index', sindex);
            $sortItem.data('mblock_index', sindex);
            
            // Reindex form elements
            mblock_reindex_form_elements($sortItem, index, sindex, mblock_count);
            
            // Reindex special elements
            mblock_reindex_special_elements($sortItem, index, sindex, mblock_count);
        });

        // Nach Reindexierung: for-Attribute korrigieren
        mblock_replace_for(element);
        
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_reindex:', error);
        return false;
    }
}

/**
 * Optimierte Behandlung von Formularelementen beim Reindexing
 */
function mblock_reindex_form_elements($sortItem, index, sindex, mblock_count) {
    try {
        $sortItem.find('input,textarea,select,button').each(function (key) {
            const $element = $(this);
            const elementId = $element.attr('id');
            const elementName = $element.attr('name');
            
            if (!elementId && !elementName) return;
            
            // Update IDs and names with new index
            if (elementId) {
                const newId = elementId.replace(/_\d+/, '_' + sindex);
                $element.attr('id', newId);
            }
            
            if (elementName) {
                const newName = elementName.replace(/\[(\d+)\]/, '[' + sindex + ']');
                $element.attr('name', newName);
            }
            
            // Handle REX fields
            mblock_update_rex_ids($element, sindex, mblock_count, key);
            mblock_update_rex_buttons($element, sindex, mblock_count, key);
        });
    } catch (error) {
        console.error('MBlock: Fehler in mblock_reindex_form_elements:', error);
    }
}

/**
 * Centralized REX-System-ID updater with unified logic
 */
function mblock_update_rex_ids($element, sindex, mblock_count, eindex) {
    try {
        const elementId = $element.attr('id');
        const nodeName = $element.prop('nodeName');
        
        if (!elementId) return;

        // Configuration for different REX field types
        const rexConfigs = [
            {
                type: 'SELECT',
                patterns: ['REX_MEDIALIST_SELECT_', 'REX_LINKLIST_SELECT_'],
                handler: (newId, nameAttr) => {
                    $element.attr('id', newId);
                    if (nameAttr) $element.attr('name', nameAttr);
                }
            },
            {
                type: 'INPUT',
                patterns: ['REX_MEDIA_', 'REX_LINKLIST_', 'REX_MEDIALIST_'],
                handler: (newId) => {
                    $element.attr('id', newId);
                }
            }
        ];

        // Find matching configuration and apply handler
        const config = rexConfigs.find(cfg => 
            cfg.type === nodeName && 
            cfg.patterns.some(pattern => elementId.indexOf(pattern) >= 0)
        );

        if (config) {
            const newId = elementId.replace(/_\d+/, '_' + sindex);
            const nameAttr = $element.attr('name')?.replace(/\[(\d+)\]/, '[' + sindex + ']');
            config.handler(newId, nameAttr);
        }

    } catch (error) {
        console.error('MBlock: Fehler in mblock_update_rex_ids:', error);
    }
}

/**
 * REX-Popup-Buttons aktualisieren
 */
function mblock_update_rex_buttons($element, sindex, mblock_count, eindex) {
    try {
        const $parent = $element.parent();
        $parent.find('a.btn-popup').each(function () {
            const $button = $(this);
            const onclick = $button.attr('onclick');
            
            if (onclick) {
                const newOnclick = onclick.replace(/_\d+/, '_' + sindex);
                $button.attr('onclick', newOnclick);
            }
        });
    } catch (error) {
        console.error('MBlock: Fehler in mblock_update_rex_buttons:', error);
    }
}

/**
 * Behandlung spezieller Elemente beim Reindexing (Bootstrap-Tabs, Accordions, etc.)
 */
function mblock_reindex_special_elements($sortItem, index, sindex, mblock_count) {
    try {
        // Bootstrap Tabs
        $sortItem.find('a[data-toggle="tab"]').each(function (key) {
            const $tab = $(this);
            const href = $tab.attr('href');
            if (href) {
                const newHref = href.replace(/_\d+/, '_' + sindex);
                $tab.attr('href', newHref);
            }
        });

        // Bootstrap Collapse/Accordion
        $sortItem.find('a[data-toggle="collapse"]').each(function (key) {
            const $collapse = $(this);
            const target = $collapse.attr('href') || $collapse.attr('data-target');
            if (target) {
                const newTarget = target.replace(/_\d+/, '_' + sindex);
                $collapse.attr('href', newTarget);
                $collapse.attr('data-target', newTarget);
            }
        });

        // Custom Links (MForm)
        $sortItem.find('.custom-link').each(function (key) {
            const $link = $(this);
            const href = $link.attr('href');
            if (href) {
                const newHref = href.replace(/_\d+/, '_' + sindex);
                $link.attr('href', newHref);
            }
        });
    } catch (error) {
        console.error('MBlock: Fehler in mblock_reindex_special_elements:', error);
    }
}

function mblock_replace_for(element) {
    element.find('> div.sortitem').each(function (index) {
        var mblock = $(this);
        mblock.find('input:not(:checkbox):not(:radio),textarea,select').each(function (key) {
            var forAttr = $(this).attr('id');
            if (forAttr) {
                var label = mblock.find('label[for="' + forAttr + '"]');
                if (label.length > 0) {
                    label.attr('for', forAttr);
                }
            }
        });
    });
}

function mblock_add_item(element, item) {
    // create iclone
    const iClone = MBlockUtils.dom.createFromHTML(element.data('mblock-plain-sortitem'));

    // fix for checkbox and radio bug
    iClone.find('input:radio, input:checkbox').each(function () {
        $(this).parent().removeAttr('for');
    });

    // fix radio bug
    iClone.find('input:radio, input:checkbox').each(function () {
        // fix lost checked from parent item
        $(this).attr('name', 'mblock_new_' + $(this).attr('name'));
        // fix lost value
        $(this).attr('data-value', $(this).val());
    });

    if (item === false) {
        // add clone
        element.prepend(iClone);
    } else if (item.parent().hasClass(element.attr('class'))) {
        item.after(iClone);
    }

    // add unique id
    mblock_set_unique_id(iClone, true);
    // reinit first
    mblock_init_sort(element);
    
    // trigger rex:ready event only on the new item for component initialization
    iClone.trigger('rex:ready', [iClone]);
    
    // CRITICAL: Initialize nested MBlocks BEFORE other components to prevent duplicate initialization
    setTimeout(function() {
        // Use utility function for safe nested MBlock initialization
        MBlockUtils.nested.initializeNested(iClone);
        
        // specific component reinitialization
        // Initialize selectpicker with REDAXO core method for new items
        if (typeof $.fn.selectpicker === 'function') {
            iClone.find('select.selectpicker').selectpicker('refresh');
        }
        
        // reinitialize other common components
        if (typeof $.fn.chosen === 'function') {
            iClone.find('select').chosen('destroy').chosen();
        }
        
        // CRITICAL FIX: Reinitialize REDAXO Media and Link functionality for new blocks
        if (typeof mblock_reinitialize_redaxo_widgets === 'function') {
            mblock_reinitialize_redaxo_widgets(iClone);
        }
        
        // trigger change events to update any dependent elements
        iClone.find('input, select, textarea').trigger('change');
    }, 50);
    
    // scroll to item with slight delay to ensure DOM is ready
    setTimeout(function() {
        if (iClone && iClone.length && iClone.is(':visible')) {
            mblock_smooth_scroll_to_element(iClone.get(0));
        }
    }, 100);
}

function mblock_set_unique_id(item, input_delete) {
    try {
        if (!item || !item.length || typeof item.find !== 'function') {
            console.warn('MBlock: Invalid item passed to mblock_set_unique_id');
            return false;
        }

        item.find('input').each(function () {
            const $input = $(this);
            const name = $input.attr('name');
            
            if (name && input_delete) {
                // Remove old unique ID from name
                const cleanName = name.replace(/_unique_\w+/, '');
                $input.attr('name', cleanName);
            }
            
            // Add new unique ID
            if (name && !name.includes('_unique_')) {
                const uniqueId = Date.now() + Math.random().toString(36).substring(2, 11);
                const newName = name.replace(/(\w+)(\[.*\])?$/, '$1_unique_' + uniqueId + '$2');
                $input.attr('name', newName);
            }
        });
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_set_unique_id:', error);
        return false;
    }
}

function mblock_set_count(element, item) {
    var countItem = item.next().find('span.mb_count'),
        count = element.find('> div.sortitem').length;

    if (element.data('latest')) {
        count = element.data('latest') + 1;
    }

    countItem.text(count);
    element.data('latest', count);
}

function mblock_remove_item(element, item) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length || !item || !item.length) {
            console.warn('MBlock: Invalid parameters passed to mblock_remove_item');
            return false;
        }

        const elementData = element.data();
        if (elementData && elementData.hasOwnProperty('delete_confirm')) {
            if (!confirm(elementData.delete_confirm)) {
                return false;
            }
        }

        const itemParent = item.parent();
        const elementClass = element.attr('class');
        
        if (itemParent.length && elementClass && itemParent.hasClass(elementClass)) {
            // Remove item safely
            MBlockUtils.dom.safeRemove(item);
            mblock_reindex(element);
            mblock_remove(element);
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_remove_item:', error);
        return false;
    }
}

function mblock_moveup(element, item) {
    var prev = item.prev();
    if (prev.length == 0) return;

    setTimeout(function () {
        item.insertBefore(prev);
        // set last user action
        mblock_reindex(element);
        mblock_remove(element);
        // trigger event
        let iClone = prev;
        iClone.trigger('mblock:change', [iClone]);
    }, 150);
}

function mblock_movedown(element, item) {
    var next = item.next();
    if (next.length == 0) return;

    setTimeout(function () {
        item.insertAfter(next);
        // set last user action
        mblock_reindex(element);
        mblock_remove(element);
        // trigger event
        let iClone = next;
        iClone.trigger('mblock:change', [iClone]);
    }, 150);
}

function mblock_scroll(element, item) {
    try {
        if (!element || !element.length || !item || !item.length) {
            console.warn('MBlock: Invalid parameters passed to mblock_scroll');
            return false;
        }

        const elementData = element.data();
        
        // Wenn smooth_scroll aktiviert ist, verwende die smooth scroll Funktion
        if (elementData && elementData.hasOwnProperty('smooth_scroll') && elementData.smooth_scroll === true) {
            mblock_smooth_scroll_to_element(item.get(0));
        }
        
        // Fallback: Standard-Browser-Scrolling zu dem Element
        if (item.length && item.offset()) {
            const offset = item.offset().top - 100; // 100px offset from top
            $('html, body').animate({ scrollTop: offset }, 500);
        }
        
        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_scroll:', error);
        return false;
    }
}

function mblock_add(element) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length) {
            console.warn('MBlock: Invalid element passed to mblock_add');
            return false;
        }

        // Centralized event handler configuration
        const eventHandlers = [
            {
                selector: MBlockUtils.selectors.addme,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    const $wrapper = $(this).closest('.mblock_wrapper');
                    mblock_add_item($wrapper, $(this).closest('.sortitem'));
                }
            },
            {
                selector: MBlockUtils.selectors.removeme,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    const $wrapper = $(this).closest('.mblock_wrapper');
                    const $item = $(this).closest('.sortitem');
                    mblock_remove_item($wrapper, $item);
                }
            },
            {
                selector: MBlockUtils.selectors.moveup,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    const $wrapper = $(this).closest('.mblock_wrapper');
                    const $item = $(this).closest('.sortitem');
                    mblock_moveup($wrapper, $item);
                }
            },
            {
                selector: MBlockUtils.selectors.movedown,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    const $wrapper = $(this).closest('.mblock_wrapper');
                    const $item = $(this).closest('.sortitem');
                    mblock_movedown($wrapper, $item);
                }
            }
        ];

        // Bind all basic event handlers
        eventHandlers.forEach(({selector, event, handler}) => {
            MBlockUtils.events.bindSafe(MBlockUtils.dom.findElement(element, selector), event, handler);
        });

        // Handle copy/paste buttons only if enabled
        if (checkCopyPasteEnabled()) {
            mblock_add._bindCopyPasteHandlers(element);
        }

        // Handle online/offline toggle buttons
        mblock_add._bindToggleHandlers(element);

        // Initialize states
        if (checkCopyPasteEnabled() && typeof MBlockClipboard !== 'undefined') {
            MBlockClipboard.updatePasteButtons();
        }
        if (typeof MBlockOnlineToggle !== 'undefined') {
            MBlockOnlineToggle.initializeStates(element);
        }

        return true;
    } catch (error) {
        console.error('MBlock: Fehler in mblock_add:', error);
        return false;
    }
}

// Private helper methods for mblock_add
mblock_add._bindCopyPasteHandlers = function(element) {
    // Copy Button Handler
    const copyButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.copyBtn}`);
    if (copyButtons.length > 0) {
        MBlockUtils.events.bindSafe(copyButtons, 'click', function (e) {
            e.preventDefault();
            const $wrapper = $(this).closest('.mblock_wrapper');
            const $item = $(this).closest('.sortitem');
            if (typeof MBlockClipboard !== 'undefined') {
                MBlockClipboard.copy($wrapper, $item);
            }
        });
    }

    // Paste Button Handler
    const pasteButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.pasteBtn}`);
    if (pasteButtons.length > 0) {
        MBlockUtils.events.bindSafe(pasteButtons, 'click', function (e) {
            e.preventDefault();
            const $wrapper = $(this).closest('.mblock_wrapper');
            const $item = $(this).closest('.sortitem');
            if (typeof MBlockClipboard !== 'undefined') {
                MBlockClipboard.paste($wrapper, $item);
            }
        });
    }
};

mblock_add._bindToggleHandlers = function(element) {
    // Online/Offline Toggle Handler (old system)
    const toggleButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.onlineToggle}`);
    MBlockUtils.events.bindSafe(toggleButtons, 'click', function (e) {
        e.preventDefault();
        try {
            const $wrapper = $(this).closest('.mblock_wrapper');
            const $item = $(this).closest('.sortitem');
            if (typeof MBlockOnlineToggle !== 'undefined') {
                MBlockOnlineToggle.toggle($wrapper, $item);
            }
        } catch (error) {
            console.error('MBlock: Error in toggle handler:', error);
        }
        return false;
    });

    // New Auto-Detected Toggle Handler
    const autoToggleButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.autoToggle}`);
    MBlockUtils.events.bindSafe(autoToggleButtons, 'click', function (e) {
        e.preventDefault();
        try {
            const $wrapper = $(this).closest('.mblock_wrapper');
            const $item = $(this).closest('.sortitem');
            const $button = $(this);
            if (typeof MBlockOnlineToggle !== 'undefined') {
                MBlockOnlineToggle.toggleAutoDetected($wrapper, $item, $button);
            }
        } catch (error) {
            console.error('MBlock: Error in auto toggle handler:', error);
        }
        return false;
    });
};

// Toolbar Initialisierung
function mblock_init_toolbar(element) {
    try {
        // Nur initialisieren wenn Copy/Paste aktiviert ist
        if (!checkCopyPasteEnabled()) {
            console.log('MBlock: Copy/Paste disabled, skipping toolbar initialization');
            return;
        }
        
        // Centralized toolbar event configuration
        const toolbarEvents = [
            {
                selector: '.mblock-copy-paste-toolbar .mblock-paste-btn',
                handler: function (e) {
                    e.preventDefault();
                    const $wrapper = $(this).closest('.mblock_wrapper');
                    if (typeof MBlockClipboard !== 'undefined') {
                        MBlockClipboard.paste($wrapper, false);
                    }
                }
            },
            {
                selector: '.mblock-copy-paste-toolbar .mblock-clear-clipboard',
                handler: function (e) {
                    e.preventDefault();
                    if (typeof MBlockClipboard !== 'undefined') {
                        MBlockClipboard.clear();
                        mblock_show_message('Zwischenablage geleert', 'info', 2000);
                    }
                }
            }
        ];

        // Bind all toolbar events
        toolbarEvents.forEach(({selector, handler}) => {
            MBlockUtils.events.bindSafe(MBlockUtils.dom.findElement(element, selector), 'click', handler);
        });
            
    } catch (error) {
        console.error('MBlock: Fehler in mblock_init_toolbar:', error);
    }
}

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockSortable };
}


// ==================== MBLOCK-FEATURES MODULE ====================
/**
 * MBlock Features - Advanced functionality
 *
 * Contains:
 * - Copy/Paste functionality (MBlockClipboard)
 * - Online/Offline toggle (MBlockOnlineToggle)
 * - REDAXO widget reinitialization
 * - REX_LINK field handling and AJAX functions
 *
 * Depends on: mblock-core.js, mblock-management.js
 *
 * @author joachim doerr
 * @version 2.0
 */

// Copy & Paste Funktionalit√§t mit Session/Local Storage
var MBlockClipboard = {
    data: null,
    storageKey: 'mblock_clipboard',
    useSessionStorage: true, // true = Session Storage, false = Local Storage

    // Initialize clipboard from storage
    init: function() {
        try {
            const loaded = this.loadFromStorage();
            if (this.data) {
                console.log('MBlock: Clipboard initialized with existing data');
            }
        } catch (error) {
            console.warn('MBlock: Fehler beim Initialisieren des Clipboards:', error);
        }
    },

    // Get storage object (sessionStorage or localStorage)
    getStorage: function() {
        try {
            return this.useSessionStorage ? sessionStorage : localStorage;
        } catch (error) {
            console.warn('MBlock: Storage nicht verf√ºgbar:', error);
            return null;
        }
    },

    // Save clipboard data to storage
    saveToStorage: function() {
        try {
            const storage = this.getStorage();
            if (storage && this.data) {
                this.data.savedAt = new Date().toISOString();
                storage.setItem(this.storageKey, JSON.stringify(this.data));
                return true;
            }
        } catch (error) {
            console.warn('MBlock: Fehler beim Speichern in Storage:', error);
        }
        return false;
    },

    // Load clipboard data from storage
    loadFromStorage: function() {
        try {
            const storage = this.getStorage();
            if (storage) {
                const stored = storage.getItem(this.storageKey);
                if (stored) {
                    this.data = JSON.parse(stored);
                    return true;
                }
            }
        } catch (error) {
            console.warn('MBlock: Fehler beim Laden aus Storage:', error);
            this.clearStorage(); // Clear corrupted storage
        }
        return false;
    },

    // Clear storage
    clearStorage: function() {
        try {
            const storage = this.getStorage();
            if (storage) {
                storage.removeItem(this.storageKey);
            }
        } catch (error) {
            console.warn('MBlock: Fehler beim Leeren des Storages:', error);
        }
    },

    // Generate simple session ID
    getSessionId: function() {
        if (!this._sessionId) {
            this._sessionId = Date.now().toString() + Math.random().toString(36).substring(2, 11);
        }
        return this._sessionId;
    },

    // Toggle between session and local storage
    toggleStorageMode: function() {
        const oldData = this.data;
        this.clearStorage(); // Clear current storage

        this.useSessionStorage = !this.useSessionStorage;

        if (oldData) {
            this.data = oldData;
            this.saveToStorage(); // Save to new storage
        }

        return this.useSessionStorage;
    },

    // Show warning when trying to paste between different module types
    showModuleTypeMismatchWarning: function(currentType, clipboardType) {
        try {
            // Create temporary warning message
            const warningHtml = `
                <div class="alert alert-warning mblock-type-warning" style="margin: 10px 0; position: relative; z-index: 1000;">
                    <strong>Achtung:</strong> Das kopierte Element stammt aus einem anderen Modul-Typ.
                    Das Einf√ºgen ist nicht m√∂glich.<br>
                    <small>Aktueller Typ: <code>${currentType}</code> | Zwischenablage: <code>${clipboardType}</code></small>
                    <button type="button" class="close" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); border: none; background: none; font-size: 18px;" onclick="$(this).parent().fadeOut()">&times;</button>
                </div>
            `;

            // Find best place to show warning
            const targetElement = $('.mblock_wrapper').first();
            if (targetElement.length) {
                targetElement.before(warningHtml);
            } else {
                $('body').prepend(warningHtml);
            }

        } catch (error) {
            console.error('MBlock: Fehler beim Anzeigen der Modultyp-Warnung:', error);
            // Fallback to browser alert
            alert('Das kopierte Element kann hier nicht eingef√ºgt werden (anderer Modul-Typ).');
        }
    },

    // Get module type/name from wrapper or form context
    getModuleType: function(wrapper) {
        try {

            // 1. Check form for hidden input with module_id (REDAXO standard!)
            const form = wrapper.closest('form');
            if (form.length) {
                const moduleIdInput = form.find('input[name="module_id"]').first();
                if (moduleIdInput.length) {
                    return 'module_' + moduleIdInput.val();
                }
            }

            // 2. Fallback: Check in wrapper for other patterns
            const moduleInputWrapper = wrapper.find('input[name="module_id"]').first();
            if (moduleInputWrapper.length) {
                return 'module_' + moduleInputWrapper.val();
            }

            // 3. Fallback: andere module_id patterns
            const moduleInputFallback = wrapper.find('input[name*="module_id"], input[name*="module_name"]').first();
            if (moduleInputFallback.length) {
                const name = moduleInputFallback.attr('name');
                const value = moduleInputFallback.val();
                return name + '_' + value;
            }

            // 4. Check for form action or parent context
            if (form.length) {
                const action = form.attr('action');
                if (action) {
                    const urlParams = new URLSearchParams(action.split('?')[1]);
                    const moduleId = urlParams.get('module_id');
                    if (moduleId) {
                        return 'module_' + moduleId;
                    }
                }
            }

            // 5. Check for unique class or id patterns on wrapper
            const classes = wrapper.attr('class') || '';
            const classMatch = classes.match(/mblock-module-(\w+)/);
            if (classMatch) {
                return classMatch[1];
            }

            // 6. Fallback: use closest identifying parent
            const parentWithId = wrapper.closest('[id]');
            if (parentWithId.length) {
                return 'parent_' + parentWithId.attr('id');
            }

            // 6. Last resort: use URL parameters (nur innerhalb des gleichen Artikels!)
            const urlParams = new URLSearchParams(window.location.search);
            const moduleId = urlParams.get('module_id') || urlParams.get('article_id');
            if (moduleId) {
                return 'url_module_' + moduleId;
            }

            // Default fallback
            console.warn('MBlock: Keine Modul-ID erkannt - verwende unknown_module');
            return 'unknown_module';

        } catch (error) {
            console.warn('MBlock: Fehler beim Ermitteln des Modultyps:', error);
            return 'unknown_module';
        }
    },

    copy: function(element, item) {

        try {
            if (!item || !item.length) {
                console.warn('MBlock: Invalid item passed to copy');
                return false;
            }


            // Get module type from the closest mblock wrapper
            const wrapper = item.closest('.mblock_wrapper');
            const moduleType = this.getModuleType(wrapper);


            // Clone item completely
            const clonedItem = item.clone(true, true);

            // Convert selectpicker elements back to plain select elements for clean copying
            this.convertSelectpickerToPlainSelect(clonedItem);

            // Capture comprehensive form data
            const formData = this.captureComplexFormData(item);


            // Store in clipboard with metadata and form values
            this.data = {
                html: clonedItem.prop('outerHTML'),
                formData: formData,
                moduleType: moduleType,
                timestamp: Date.now(),
                source: element.attr('class') || 'mblock_wrapper'
            };


            // Visual feedback
            this.showCopiedState(item);

            // Save to storage
            const saved = this.saveToStorage();

            // Update paste button states
            this.updatePasteButtons();

            return true;

        } catch (error) {
            console.error('MBlock: Fehler beim Kopieren:', error);
            return false;
        }
    },

    captureComplexFormData: function(item) {
        const formData = {};

        try {
            // Regular form elements
            item.find('input, textarea, select').each(function() {
                const $field = $(this);
                const name = $field.attr('name');
                const type = $field.attr('type');

                if (name) {
                    if (type === 'checkbox' || type === 'radio') {
                        formData[name] = {
                            type: 'checkbox_radio',
                            checked: $field.is(':checked'),
                            value: $field.val()
                        };
                    } else if ($field.is('select')) {
                        formData[name] = {
                            type: 'select',
                            value: $field.val(),
                            multiple: $field.prop('multiple')
                        };
                    } else {
                        formData[name] = {
                            type: 'input',
                            value: $field.val()
                        };
                    }
                }
            });

            // CKEditor content (CKE5)
            item.find('.cke5-editor').each(function() {
                const $editor = $(this);
                const editorId = $editor.attr('id');
                if (editorId && window.CKEDITOR && window.CKEDITOR.instances[editorId]) {
                    const content = window.CKEDITOR.instances[editorId].getData();
                    formData[editorId] = {
                        type: 'ckeditor',
                        value: content
                    };
                }
            });

            // REX_LINK widgets (comprehensive handling)
            item.find('input[id^="REX_LINK_"]').each(function() {
                const $linkInput = $(this);
                const id = $linkInput.attr('id');
                const value = $linkInput.val();

                formData[id] = {
                    type: 'rex_link',
                    value: value
                };

                // Also capture display field if it exists
                const displayId = id.replace('REX_LINK_', 'REX_LINK_NAME_');
                const $displayField = $('#' + displayId);
                if ($displayField.length) {
                    formData[displayId] = {
                        type: 'rex_link_display',
                        value: $displayField.val()
                    };
                }
            });

            // REX_MEDIA widgets
            item.find('input[id^="REX_MEDIA_"]').each(function() {
                const $mediaInput = $(this);
                const id = $mediaInput.attr('id');
                const value = $mediaInput.val();

                formData[id] = {
                    type: 'rex_media',
                    value: value
                };
            });

            // Additional field types can be added here...
            // (REX Media widgets, REX Link widgets, etc. - abbreviated for brevity)

            return formData;

        } catch (error) {
            console.error('MBlock: Fehler beim Erfassen der Formulardaten:', error);
            return formData;
        }
    },

    paste: function(element, afterItem) {
        try {
            // Load fresh data from storage in case it was updated in another tab
            this.loadFromStorage();

            if (!this.data) {
                mblock_show_message(mblock_get_text('mblock_toast_clipboard_empty', 'Keine Daten in der Zwischenablage'), 'warning', 3000);
                return false;
            }

            // Check module type compatibility
            const currentWrapper = element.closest('.mblock_wrapper');
            const currentModuleType = this.getModuleType(currentWrapper);
            const clipboardModuleType = this.data.moduleType || 'unknown_module';

            if (currentModuleType !== clipboardModuleType) {
                this.showModuleTypeMismatchWarning(currentModuleType, clipboardModuleType);
                return false;
            }


            // Create element from clipboard
            const pastedItem = $(this.data.html);

            // Clean up IDs and names to avoid conflicts
            this.cleanupPastedItem(pastedItem);

            // Insert item
            if (afterItem && afterItem.length) {
                afterItem.after(pastedItem);
            } else {
                element.prepend(pastedItem);
            }

            // Add unique ids
            mblock_set_unique_id(pastedItem, true);

            // CRITICAL: Reinitialize widgets BEFORE form data restoration
            if (typeof mblock_reinitialize_redaxo_widgets === 'function') {
                mblock_reinitialize_redaxo_widgets(pastedItem);
            }

            // Destroy existing CKEditor5 instances before reindexing
            pastedItem.find('.cke5-editor').each(function() {
                const $editor = $(this);
                const editorId = $editor.attr('id');
                if (editorId && window.CKEDITOR && window.CKEDITOR.instances[editorId]) {
                    window.CKEDITOR.instances[editorId].destroy();
                }
            });

            // Restore NON-CKEditor form values first
            if (this.data.formData) {
                this.restoreNonCKEditorFormData(pastedItem, this.data.formData);
            }

            // Reinitialize sortable
            mblock_init_sort(element);

            // Trigger rex:ready event for full reinitialization (including CKEditor5)
            pastedItem.trigger('rex:ready', [pastedItem]);

            // CRITICAL: Handle nested MBlock wrappers inside pasted content (GridBlock compatibility)
            try {
                pastedItem.find('.mblock_wrapper').each(function() {
                    const $nestedWrapper = $(this);
                    if (!$nestedWrapper.data('mblock_initialized')) {
                        mblock_init($nestedWrapper);
                        $nestedWrapper.data('mblock_initialized', true);
                    }
                });
            } catch (e) {
                console.warn('MBlock: Error initializing nested MBlocks in pasted content:', e);
            }

            // Wait for CKEditor5 initialization, then restore content
            if (this.data.formData) {
                setTimeout(() => {
                    this.restoreCKEditorFormData(pastedItem, this.data.formData);
                }, 100);
            }

            // Component reinitialization
            setTimeout(() => {
                // Reinitialize selectpickers
                if (typeof $.fn.selectpicker === 'function') {
                    pastedItem.find('select.selectpicker').selectpicker('refresh');
                }

                // Reinitialize chosen
                if (typeof $.fn.chosen === 'function') {
                    pastedItem.find('select').chosen('destroy').chosen();
                }

                // Trigger change events
                pastedItem.find('input, select, textarea').trigger('change');
            }, 50);

            // Scroll to pasted item
            setTimeout(() => {
                if (pastedItem && pastedItem.length && pastedItem.is(':visible')) {
                    mblock_smooth_scroll_to_element(pastedItem.get(0));
                }
            }, 100);

            // ‚ú® Add glow effect to pasted item using utility
            setTimeout(() => {
                MBlockUtils.animation.flashEffect(pastedItem);
                mblock_show_message(mblock_get_text('mblock_toast_paste_success', 'Block erfolgreich eingef√ºgt!'), 'success', 3000);
            }, 150);

            return true;

        } catch (error) {
            console.error('MBlock: Fehler beim Einf√ºgen:', error);
            return false;
        }
    },

    cleanupPastedItem: function(item) {
        try {

            // Remove mblock-specific data attributes
            item.removeAttr('data-mblock_index');

            // Clean form elements
            item.find('input, textarea, select').each(function() {
                const $field = $(this);
                // Remove IDs to avoid conflicts
                $field.removeAttr('id');
                // Clean names
                const name = $field.attr('name');
                if (name) {
                    const cleanName = name.replace(/_unique_\w+/, '');
                    $field.attr('name', cleanName);
                }
            });

            // Clean IDs that might cause conflicts
            item.find('[id]').each(function() {
                const $element = $(this);
                const id = $element.attr('id');
                if (id && (id.includes('REX_') || id.includes('mblock'))) {
                    $element.removeAttr('id');
                }
            });

        } catch (error) {
            console.error('MBlock: Fehler beim Bereinigen des eingef√ºgten Items:', error);
        }
    },

    restoreNonCKEditorFormData: function(pastedItem, formData) {
        try {
            Object.keys(formData).forEach(originalName => {
                const fieldData = formData[originalName];
                if (fieldData.type !== 'ckeditor') {
                    this.restoreFieldData(pastedItem.find('[name="' + originalName + '"]'), fieldData, pastedItem, originalName);
                }
            });
        } catch (error) {
            console.error('MBlock: Fehler beim Wiederherstellen der Nicht-CKEditor-Daten:', error);
        }
    },

    restoreCKEditorFormData: function(pastedItem, formData) {
        try {
            Object.keys(formData).forEach(originalName => {
                const fieldData = formData[originalName];
                if (fieldData.type === 'ckeditor') {
                    const $editor = pastedItem.find('#' + originalName);
                    if ($editor.length && window.CKEDITOR && window.CKEDITOR.instances[originalName]) {
                        window.CKEDITOR.instances[originalName].setData(fieldData.value);
                    }
                }
            });
        } catch (error) {
            console.error('MBlock: Fehler beim Wiederherstellen der CKEditor-Daten:', error);
        }
    },

    restoreFieldData: function($field, fieldData, pastedItem, originalName) {
        // Handle different field types
        switch (fieldData.type) {
            case 'checkbox_radio':
                if (fieldData.checked) {
                    $field.prop('checked', true);
                }
                break;

            case 'select':
                $field.val(fieldData.value);
                if (typeof $.fn.selectpicker === 'function') {
                    $field.selectpicker('refresh');
                }
                break;

            case 'rex_link':
                $field.val(fieldData.value);
                // Trigger article name fetch if value exists
                if (fieldData.value) {
                    const displayId = originalName.replace('REX_LINK_', 'REX_LINK_NAME_');
                    const $displayField = pastedItem.find('#' + displayId);
                    if ($displayField.length) {
                        mblock_fetch_article_name(fieldData.value, $displayField);
                    }
                }
                break;

            case 'rex_media':
                $field.val(fieldData.value);
                break;

            default:
                // Handle regular input fields
                if (fieldData.value !== undefined) {
                    $field.val(fieldData.value);
                }
                break;
        }
    },

    showCopiedState: function(item) {
        // Visual feedback using centralized animation utility
        MBlockUtils.animation.addGlowEffect(item, 'mblock-copy-glow', 1000);

        // Centralized copy feedback
        const copyMessage = 'üìã ' + mblock_get_text('mblock_toast_copy_success', 'Block erfolgreich kopiert!');
        mblock_show_message(copyMessage, 'success', 3000);

        // Optional: Also give feedback to the copy button if it exists
        const $copyBtn = item.find('.mblock-copy-btn');
        if ($copyBtn.length) {
            MBlockUtils.animation.addGlowEffect($copyBtn, 'is-copied', 1000);
        }
    },

    updatePasteButtons: function() {
        const hasData = !!this.data;


        if (hasData) {
            // Pr√ºfe Modulkompatibilit√§t f√ºr alle sichtbaren MBlock-Wrapper
            $('.mblock_wrapper').each((index, wrapperElement) => {
                const $wrapper = $(wrapperElement);
                const wrapperModuleType = this.getModuleType($wrapper);
                const clipboardModuleType = this.data.moduleType || 'unknown_module';
                const isCompatible = wrapperModuleType === clipboardModuleType;

                // Update paste buttons in this wrapper
                $wrapper.find('.mblock-paste-btn').each(function() {
                    const $btn = $(this);
                    $btn.toggleClass('disabled', !isCompatible);
                    $btn.prop('disabled', !isCompatible);
                    $btn.attr('title', isCompatible ?
                        'Block einf√ºgen' :
                        'Block kann nicht eingef√ºgt werden (anderer Modul-Typ)');
                });
            });
        } else {
            // Keine Daten - alle Buttons deaktivieren
            $('.mblock-paste-btn').addClass('disabled').prop('disabled', true);
            $('.mblock-paste-btn').attr('title', 'No data in clipboard');
        }

        // Update toolbar visibility
        const toolbar = $('.mblock-copy-paste-toolbar');
        if (hasData) {
            toolbar.show();
        } else {
            toolbar.hide();
        }

        // Update button text with storage info
        const storageInfo = this.useSessionStorage ? 'Session' : 'Local';
    },

    // Convert selectpicker elements back to plain select elements
    convertSelectpickerToPlainSelect: function(container) {
        try {

            // Find all select elements that have selectpicker class or are inside bootstrap-select wrappers
            const $selectElements = container.find('select.selectpicker, .bootstrap-select select');

            $selectElements.each(function() {
                const $select = $(this);
                const $wrapper = $select.closest('.bootstrap-select');

                if ($wrapper.length) {
                    // Move select out of wrapper and remove wrapper
                    $wrapper.before($select);
                    $wrapper.remove();
                }

                // Remove selectpicker classes and data
                $select.removeClass('selectpicker');
                $select.removeAttr('data-live-search');
                $select.removeAttr('data-size');
                $select.removeAttr('data-style');
                $select.show(); // Make sure it's visible
            });

            // Clean up any remaining empty bootstrap-select containers
            container.find('.bootstrap-select').each(function() {
                const $wrapper = $(this);
                if ($wrapper.find('select').length === 0) {
                    $wrapper.remove();
                }
            });


        } catch (error) {
            console.error('MBlock: Error converting selectpicker to plain select:', error);
        }
    },

    clear: function() {
        this.data = null;
        this.clearStorage();
        this.updatePasteButtons();
    },

    // Get clipboard info for debugging
    getInfo: function() {
        return {
            hasData: !!this.data,
            storageMode: this.useSessionStorage ? 'Session' : 'Local',
            timestamp: this.data ? this.data.timestamp : null,
            savedAt: this.data ? this.data.savedAt : null,
            itemCount: this.data && this.data.formData ? Object.keys(this.data.formData).length : 0
        };
    }
};

// Online/Offline Toggle Funktionalit√§t
var MBlockOnlineToggle = {

    toggle: function(element, item) {
        try {
            if (!item || !item.length) {
                console.warn('MBlock: Invalid item passed to toggle');
                return false;
            }

            const isOnline = !item.hasClass('mblock-offline');
            const $toggleBtn = item.find('.mblock-online-toggle');
            const $icon = $toggleBtn.find('i');

            if (isOnline) {
                // Set offline
                item.addClass('mblock-offline');
                $toggleBtn.attr('title', 'Set online');
                if ($icon.length) {
                    $icon.removeClass('rex-icon-online').addClass('rex-icon-offline');
                }
                $toggleBtn.find('.toggle-text').text('Offline');
                this.setOfflineState(item, true);
            } else {
                // Set online
                item.removeClass('mblock-offline');
                $toggleBtn.attr('title', 'Set offline');
                if ($icon.length) {
                    $icon.removeClass('rex-icon-offline').addClass('rex-icon-online');
                }
                $toggleBtn.find('.toggle-text').text('Online');
                this.setOfflineState(item, false);
            }

            return true;

        } catch (error) {
            console.error('MBlock: Fehler beim Online/Offline Toggle:', error);
            return false;
        }
    },

    setOfflineState: function(item, isOffline) {
        try {
            // Look for existing mblock_offline input (must be defined in template)
            const $offlineInput = item.find('input[name*="mblock_offline"]');

            if ($offlineInput.length) {
                $offlineInput.val(isOffline ? '1' : '0');
            } else {
                console.warn('MBlock: No mblock_offline input found in item');
            }


        } catch (error) {
            console.error('MBlock: Fehler beim Setzen des Offline-Status:', error);
        }
    },

    initializeStates: function(element) {
        try {

            // Initialize toggle buttons based on existing offline states
            element.find('> div.sortitem').each(function(index) {
                const $item = $(this);
                const $offlineInput = $item.find('input[name*="mblock_offline"]');
                const $toggleBtn = $item.find('.mblock-online-toggle');

                if ($offlineInput.length && $toggleBtn.length) {
                    const isOffline = $offlineInput.val() === '1';

                    if (isOffline) {
                        $item.addClass('mblock-offline');
                        $toggleBtn.attr('title', 'Set online');
                        $toggleBtn.find('i').removeClass('rex-icon-online').addClass('rex-icon-offline');
                        $toggleBtn.find('.toggle-text').text('Offline');
                    } else {
                        $item.removeClass('mblock-offline');
                        $toggleBtn.attr('title', 'Set offline');
                        $toggleBtn.find('i').removeClass('rex-icon-offline').addClass('rex-icon-online');
                        $toggleBtn.find('.toggle-text').text('Online');
                    }
                }
            });


        } catch (error) {
            console.error('MBlock: Fehler beim Initialisieren der Online/Offline-States:', error);
        }
    },

    // New method for auto-detected offline toggle buttons
    toggleAutoDetected: function(element, item, button) {
        try {
            if (!item || !item.length || !button || !button.length) {
                console.warn('MBlock: Invalid parameters for toggleAutoDetected');
                return false;
            }

            // Get current offline status from button data attribute
            const currentIsOffline = button.attr('data-offline') === '1';
            const newIsOffline = !currentIsOffline;

            // Find the corresponding mblock_offline input field
            const $offlineInput = item.find('input[name*="mblock_offline"]');

            if (!$offlineInput.length) {
                console.warn('MBlock: No mblock_offline input found for auto-detected toggle');
                return false;
            }

            // Update the input value
            $offlineInput.val(newIsOffline ? '1' : '0');

            // Update button appearance with improved colors
            const buttonClass = newIsOffline ? 'btn-danger' : 'btn-success'; // Red for offline, green for online
            const iconClass = newIsOffline ? 'rex-icon-offline' : 'rex-icon-online';
            const buttonTitle = newIsOffline ? 'Set online' : 'Set offline';
            const buttonText = newIsOffline ? 'Offline' : 'Online';

            // Update button attributes and classes
            button.removeClass('btn-default btn-warning btn-success btn-danger')
                  .addClass(buttonClass)
                  .attr('title', buttonTitle)
                  .attr('data-offline', newIsOffline ? '1' : '0');

            // Update icon and text
            const $icon = button.find('i');
            if ($icon.length) {
                $icon.removeClass('rex-icon-online rex-icon-offline').addClass(iconClass);
            }

            // Update button text
            const textContent = button.html().replace(/Offline|Online/, buttonText);
            button.html(textContent);

            // Update item CSS class
            if (newIsOffline) {
                item.addClass('mblock-offline');
            } else {
                item.removeClass('mblock-offline');
            }

            return true;

        } catch (error) {
            console.error('MBlock: Fehler beim Auto-Detected Toggle:', error);
            return false;
        }
    }
};

/**
 * Critical function to reinitialize REDAXO Media and Link widgets in new blocks
 * This fixes the issue where media/link selection doesn't work in dynamically added blocks
 */
function mblock_reinitialize_redaxo_widgets(container) {
    try {
        if (!container || !container.length) {
            console.warn('MBlock: Invalid container passed to reinitialize_redaxo_widgets');
            return false;
        }

        // Get context information
        const mblockIndex = parseInt(container.attr('data-mblock_index')) || 1;
        const mblockWrapper = container.closest('.mblock_wrapper');
        const mblockCount = mblockWrapper.find('.sortitem').length || 1;
        const isGridBlock = container.closest('.gridblock_wrapper').length > 0 || container.hasClass('gridblock-item');

        console.log('MBlock: Widget-Reinitialisierung gestartet', {
            mblockIndex: mblockIndex,
            isGridBlock: isGridBlock,
            containerClass: container.attr('class')
        });

        // üîß REX MEDIA widgets - Enhanced for GridBlock compatibility
        container.find('input[id^="REX_MEDIA_"]').each(function() {
            const $mediaInput = $(this);
            const originalId = $mediaInput.attr('id');
            const newId = originalId.replace(/_\d+$/, '_' + mblockIndex);

            $mediaInput.attr('id', newId);

            // Update associated button if it exists
            const buttonSelector = 'a[href*="media_id=' + originalId.replace('REX_MEDIA_', '') + '"]';
            container.find(buttonSelector).each(function() {
                const $button = $(this);
                const href = $button.attr('href');
                if (href) {
                    const newHref = href.replace(/media_id=\d+/, 'media_id=' + mblockIndex);
                    $button.attr('href', newHref);
                }
            });
        });

        // üîß REX LINK widgets - Enhanced for GridBlock compatibility
        container.find('input[id^="REX_LINK_"]').each(function() {
            const $linkInput = $(this);
            const originalId = $linkInput.attr('id');
            const newId = originalId.replace(/_\d+$/, '_' + mblockIndex);

            $linkInput.attr('id', newId);

            // Update associated button if it exists
            const buttonSelector = 'a[href*="link_id=' + originalId.replace('REX_LINK_', '') + '"]';
            container.find(buttonSelector).each(function() {
                const $button = $(this);
                const href = $button.attr('href');
                if (href) {
                    const newHref = href.replace(/link_id=\d+/, 'link_id=' + mblockIndex);
                    $button.attr('href', newHref);
                }
            });
        });

        // üîß REX LINKLIST widgets
        container.find('input[id^="REX_LINKLIST_"]').each(function() {
            const $linklistInput = $(this);
            const originalId = $linklistInput.attr('id');
            const newId = originalId.replace(/_\d+$/, '_' + mblockIndex);

            $linklistInput.attr('id', newId);
        });

        // üîß GridBlock-specific: Trigger rex:ready event for custom widgets
        if (isGridBlock) {
            container.trigger('rex:ready', [container]);
        }

        // üîß General widget reinitialization
        setTimeout(() => {
            // Reinitialize any custom widgets that might need it
            if (typeof $.fn.selectpicker === 'function') {
                container.find('select.selectpicker').selectpicker('refresh');
            }

            if (typeof $.fn.chosen === 'function') {
                container.find('select').chosen('destroy').chosen();
            }
        }, 50);

        console.log('MBlock: REDAXO widgets erfolgreich reinitialisiert f√ºr', isGridBlock ? 'GridBlock' : 'Standard MBlock');

        return true;

    } catch (error) {
        console.error('MBlock: Fehler bei der Reinitialisierung der REDAXO Widgets:', error);
        return false;
    }
}

// üîß AJAX-Funktion zum Holen von Artikel-Namen f√ºr REX_LINK Felder
function mblock_fetch_article_name(articleId, $displayField) {
    if (!articleId || !$displayField || !$displayField.length) return;

    // Cache f√ºr bereits geladene Artikel-Namen
    if (!window.mblock_article_cache) {
        window.mblock_article_cache = {};
    }

    // Aus Cache verwenden falls vorhanden
    if (window.mblock_article_cache[articleId]) {
        $displayField.val(window.mblock_article_cache[articleId]);
        console.log('MBlock: Artikel-Name aus Cache:', window.mblock_article_cache[articleId], 'f√ºr ID:', articleId);
        return;
    }

    // AJAX-Request an REDAXO Structure Linkmap
    const currentClang = $('input[name="clang"]').val() || 1;
    const ajaxUrl = rex.backend + '?page=structure/linkmap&opener_input_field=temp&article_id=' + articleId + '&clang=' + currentClang;

    $.ajax({
        url: ajaxUrl,
        method: 'GET',
        timeout: 5000,
        success: function(response) {
            // Artikel-Name aus Response extrahieren
            let articleName = '';

            // Verschiedene Patterns versuchen
            const patterns = [
                /<a[^>]+onclick="[^"]*selectLink[^"]*"[^>]*>([^<]+)</gi,
                /<span[^>]*class="[^"]*article[^"]*"[^>]*>([^<]+)</gi,
                /article_name['"]*:\s*['"]([^'"]+)['"]/gi,
                /"name"\s*:\s*"([^"]+)"/gi
            ];

            for (const pattern of patterns) {
                const match = pattern.exec(response);
                if (match && match[1]) {
                    articleName = match[1].trim();
                    break;
                }
            }

            // Fallback: ID mit Artikel-Prefix verwenden
            if (!articleName) {
                articleName = 'Artikel [' + articleId + ']';
            }

            // In Cache speichern und Display-Feld setzen
            window.mblock_article_cache[articleId] = articleName;
            $displayField.val(articleName);
            $displayField.trigger('change');

            console.log('MBlock: Artikel-Name per AJAX geholt:', articleName, 'f√ºr ID:', articleId);
        },
        error: function() {
            // Fallback bei AJAX-Fehler
            const fallbackName = 'Artikel [' + articleId + ']';
            window.mblock_article_cache[articleId] = fallbackName;
            $displayField.val(fallbackName);

            console.log('MBlock: Artikel-Name Fallback verwendet:', fallbackName, 'f√ºr ID:', articleId);
        }
    });
}

// üöÄ AUTO-INITIALIZATION: Bef√ºlle leere REX_LINK Display-Felder beim Seitenladen
$(document).ready(function() {
    // Warte bis REDAXO vollst√§ndig geladen ist
    setTimeout(function() {
        mblock_initialize_empty_rex_link_fields();
    }, 500);

    // üîß TAB-SUPPORT: Initialisiere REX_LINK-Felder wenn Tabs gewechselt werden
    $(document).on('shown.bs.tab', function(e) {
        // Verz√∂gere die Initialisierung, da Tab-Inhalte Zeit brauchen um sichtbar zu werden
        setTimeout(function() {
            mblock_initialize_empty_rex_link_fields();
        }, 100);
    });

    // Alternative f√ºr verschiedene Tab-Systeme (Bootstrap 3/4/5 + MForm)
    $(document).on('click', '.nav-tabs a, .nav-pills a, [data-toggle="tab"], [data-bs-toggle="tab"], .mform-tabs a', function() {
        setTimeout(function() {
            mblock_initialize_empty_rex_link_fields();
        }, 200);
    });

    // üîß MForm-spezifische Tab-Events
    $(document).on('mform:tabChanged mform:tabShow', function(e) {
        setTimeout(function() {
            mblock_initialize_empty_rex_link_fields();
        }, 150);
    });
});

// üîß Bef√ºlle alle leeren REX_LINK Display-Felder mit Artikel-Namen
function mblock_initialize_empty_rex_link_fields() {
    try {
        console.log('MBlock: Initialisiere leere REX_LINK Display-Felder...');
        let foundFields = 0;
        let processedFields = 0;

        // Finde alle REX_LINK Hidden-Inputs mit Werten (auch in versteckten Tabs)
        $('input[id^="REX_LINK_"]').each(function() {
            const $linkInput = $(this);
            const linkId = $linkInput.attr('id');
            const articleId = $linkInput.val();

            if (articleId && articleId !== '0') {
                foundFields++;

                // Finde zugeh√∂riges Display-Feld
                const displayId = linkId.replace('REX_LINK_', 'REX_LINK_NAME_');
                const $displayField = $('#' + displayId);

                if ($displayField.length && !$displayField.val()) {
                    processedFields++;
                    mblock_fetch_article_name(articleId, $displayField);
                }
            }
        });

        console.log('MBlock: REX_LINK Initialisierung abgeschlossen. Gefunden:', foundFields, 'Verarbeitet:', processedFields);

    } catch (error) {
        console.error('MBlock: Fehler beim Initialisieren der REX_LINK Display-Felder:', error);
    }
}

// üîß CKEditor5 Content Restoration after rex:ready
$(document).on('rex:ready', function(e, container) {
    // Restore CKEditor5 content for pasted items
    container.find('.cke5-editor[data-cke5-restore-content]').each(function() {
        const $editor = $(this);
        const editorId = $editor.attr('id');
        const restoreContent = $editor.attr('data-cke5-restore-content');

        if (editorId && restoreContent) {
            if (window.CKEDITOR && window.CKEDITOR.instances[editorId]) {
                window.CKEDITOR.instances[editorId].setData(restoreContent);
            }
            $editor.removeAttr('data-cke5-restore-content');
        }
    });
});

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockClipboard, MBlockOnlineToggle };
}
