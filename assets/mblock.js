/**
 * MBlock Combined - Generated from modular sources
 * 
 * Build Date: Tue Sep 16 2025 12:07:13 GMT+0000 (Coordinated Universal Time)
 * Source Files: mblock-core.js + widgets.js + addonfixes.js + mblock-management.js + mblock-features.js
 * 
 * This file is automatically generated. Do not edit manually!
 * Edit the individual modular files instead.
 */

// ==================== MBLOCK-CORE.JS ====================
/**
 * MBlock Core - Base functionality and utilities
 * 
 * Contains:
 * - Core utilities (MBlockUtils)
 * - Basic validation and helper functions
 * - Message handling
 * - Translation functions
 * - Element validation
 * 
 * @author joachim doerr
 * @version 2.0
 */

let mblock = '.mblock_wrapper';

// üîß Central Utility Object - Reduces redundancy and provides reusable functions
const MBlockUtils = {
    // Cached selectors for better performance
    selectors: {
        wrapper: '.mblock_wrapper',
        sortitem: '> div.sortitem',
        addme: '.addme',
        removeme: '.removeme',
        moveup: '.moveup',
        movedown: '.movedown',
        copyBtn: '.mblock-copy-btn',
        pasteBtn: '.mblock-paste-btn',
        onlineToggle: '.mblock-online-toggle',
        autoToggle: '.mblock-offline-toggle-btn'
    },

    // DOM manipulation helpers
    dom: {
        findElement(container, selector) {
            return container?.find ? container.find(selector) : $(selector);
        },

        safeRemove(element) {
            if (element?.length) {
                element.find('*').off('.mblock');
                element.off('.mblock');
                element.remove();
                return true;
            }
            return false;
        },

        createFromHTML(html) {
            return $($.parseHTML(html));
        }
    },

    // Event handling utilities
    events: {
        bindSafe(element, event, handler, namespace = '.mblock') {
            if (element?.length) {
                element.off(event + namespace).on(event + namespace, handler);
            }
        },

        cleanup(element, namespace = '.mblock') {
            if (mblock_validate_element(element) && element.jquery) {
                element.find('*').off(namespace);
                element.off(namespace);
            }
        }
    },

    // State management
    state: {
        isDisabled(element) {
            return element.prop('disabled') || element.hasClass('disabled');
        },

        toggleDisabled(element, disabled) {
            element.prop('disabled', disabled);
            element.toggleClass('disabled', disabled);
        }
    },

    // Nested MBlock utilities for GridBlock compatibility (reference to addon fixes)
    nested: {
        /**
         * Clean up duplicate elements in nested MBlocks
         * @param {jQuery} container - Container to clean
         */
        cleanupDuplicates(container) {
            if (typeof MBlockAddonFixes !== 'undefined') {
                return MBlockAddonFixes.gridblock.cleanupDuplicates(container);
            }
        },

        /**
         * Initialize nested MBlocks safely
         * @param {jQuery} container - Container with nested MBlocks
         */
        initializeNested(container) {
            if (typeof MBlockAddonFixes !== 'undefined') {
                return MBlockAddonFixes.gridblock.initializeNested(container);
            }
        }
    },

    // Animation utilities
    animation: {
        addGlowEffect(element, className = 'mblock-copy-glow', duration = 1000) {
            if (element?.length) {
                element.addClass(className);
                setTimeout(() => element.removeClass(className), duration);
            }
        },

        flashEffect(element, className = 'mblock-dropped-flash', duration = 600) {
            if (element?.length) {
                element.addClass(className);
                setTimeout(() => element.removeClass(className), duration);
            }
        }
    },

    // Type checking utilities
    is: {
        validElement(element) {
            return mblock_validate_element(element);
        },

        rexField(id, type) {
            return id && id.indexOf(`REX_${type}_`) >= 0;
        },

        hiddenInput(element) {
            return element.attr('type') === 'hidden';
        }
    }
};

// üîß Helper function for improved error/warning feedback using bloecks
function mblock_show_message(message, type = 'warning', duration = 5000) {
    // Try to use bloecks toast system first with specific mblock method
    if (typeof BLOECKS !== 'undefined' && BLOECKS.fireMBlockToast) {
        BLOECKS.fireMBlockToast(message, type, duration);
    } else if (typeof BLOECKS !== 'undefined' && BLOECKS.showToast) {
        // Fallback to general showToast method
        BLOECKS.showToast(message, type, duration);
    } else {
        // Use internal toast fallback if available
        if (typeof MBLOCK_TOAST !== 'undefined' && MBLOCK_TOAST.show) {
            MBLOCK_TOAST.show(message, type, duration);
            return;
        }

        // Fallback to console
        if (type === 'error' || type === 'danger') {
            console.error('MBlock:', message);
        } else {
            console.warn('MBlock:', message);
        }
    }
}

// Simple namespaced toast fallback used when BLOECKS toast isn't available
const MBLOCK_TOAST = (function () {
    let counter = 0;
    let container = null;

    function createContainer() {
        if (container) return container;
        container = document.createElement('div');
        container.className = 'mblock-toast-container';
        container.style.position = 'fixed';
        container.style.top = '20px';
        container.style.right = '20px';
        container.style.zIndex = 99999;
        container.style.display = 'flex';
        container.style.flexDirection = 'column';
        container.style.gap = '8px';
        document.body.appendChild(container);
        return container;
    }

    function show(message, type = 'info', duration = 4000) {
        try {
            const cont = createContainer();
            const id = 'mblock-toast-' + (++counter);
            const toast = document.createElement('div');
            toast.id = id;
            toast.className = 'mblock-toast mblock-toast-' + type;
            toast.style.minWidth = '180px';
            toast.style.maxWidth = '420px';
            toast.style.padding = '10px 14px';
            toast.style.borderRadius = '4px';
            toast.style.boxShadow = '0 2px 8px rgba(0,0,0,0.12)';
            toast.style.background = type === 'error' || type === 'danger' ? '#f8d7da' : (type === 'success' ? '#d4edda' : '#fff3cd');
            toast.style.color = '#222';
            toast.style.border = '1px solid rgba(0,0,0,0.06)';
            toast.style.fontSize = '13px';
            toast.innerText = message;
            cont.appendChild(toast);

            setTimeout(() => {
                try { toast.style.opacity = '0'; toast.style.transition = 'opacity 250ms ease'; } catch (e) {}
            }, Math.max(50, duration - 250));

            setTimeout(() => {
                try { if (toast.parentNode) toast.parentNode.removeChild(toast); } catch (e) {}
            }, duration + 100);
            return id;
        } catch (e) {
            console.warn('MBlock: Toast fallback failed', e);
            return false;
        }
    }

    return { show };
})();

// üåç Helper function to get translated text for toast messages
function mblock_get_text(key, fallback = '') {
    // Primary: Use server-provided translations (via boot.php)
    if (typeof rex !== 'undefined' && rex.mblock_i18n && rex.mblock_i18n[key.replace('mblock_toast_', '')]) {
        return rex.mblock_i18n[key.replace('mblock_toast_', '')];
    }
    
    // Secondary: Try rex_i18n if available
    if (typeof rex !== 'undefined' && rex.i18n) {
        const text = rex.i18n.msg(key);
        return text !== key ? text : fallback; // Return fallback if key not found
    }
    
    // Fallback to simple translations if rex is not available
    const translations = {
        'mblock_toast_copy_success': {
            'de': 'Block erfolgreich kopiert!',
            'en': 'Block copied successfully!',
            'es': '¬°Bloque copiado con √©xito!',
            'pt': 'Bloco copiado com sucesso!',
            'sv': 'Block kopierat framg√•ngsrikt!',
            'nl': 'Blok succesvol gekopieerd!'
        },
        'mblock_toast_paste_success': {
            'de': 'Block erfolgreich eingef√ºgt!',
            'en': 'Block pasted successfully!',
            'es': '¬°Bloque pegado con √©xito!',
            'pt': 'Bloco colado com sucesso!',
            'sv': 'Block inklistrat framg√•ngsrikt!',
            'nl': 'Blok succesvol geplakt!'
        },
        'mblock_toast_clipboard_empty': {
            'de': 'Keine Daten in der Zwischenablage',
            'en': 'No data in clipboard',
            'es': 'No hay datos en el portapapeles',
            'pt': 'Nenhum dado na √°rea de transfer√™ncia',
            'sv': 'Inga data i urklipp',
            'nl': 'Geen gegevens in klembord'
        },
        'mblock_toast_module_type_mismatch': {
            'de': 'Modultyp stimmt nicht √ºberein',
            'en': 'Module type mismatch',
            'es': 'No coincide el tipo de m√≥dulo',
            'pt': 'Tipo de m√≥dulo n√£o corresponde',
            'sv': 'Modultyp matchar inte',
            'nl': 'Moduletype komt niet overeen'
        }
    };
    
    // Get browser language or default to German
    const lang = (navigator.language || 'de').substring(0, 2);
    const langData = translations[key];
    
    if (langData && langData[lang]) {
        return langData[lang];
    } else if (langData && langData['de']) {
        return langData['de']; // Fallback to German
    }
    
    return fallback;
}

/**
 * Utility function for safe jQuery element validation
 * @param {jQuery|HTMLElement|string} element - Element to validate
 * @returns {boolean} Whether element is valid
 */
function mblock_validate_element(element) {
    try {
        if (!element) return false;
        
        // Check jQuery object
        if (element.jquery) {
            return element.length > 0 && typeof element.data === 'function';
        }
        
        // Check DOM element
        if (element.nodeType) {
            return true;
        }
        
        // Check string selector
        if (typeof element === 'string') {
            return element.length > 0;
        }
        
        return false;
    } catch (error) {
        console.error('MBlock: Error in element validation:', error);
        return false;
    }
}

/**
 * Safe event cleanup function for better memory management
 * @param {jQuery} element - Element whose events should be cleaned up
 * @param {string} namespace - Event namespace (optional)
 */
function mblock_cleanup_events(element, namespace = '.mblock') {
    try {
        if (mblock_validate_element(element) && element.jquery) {
            // Remove all event listeners with namespace
            element.find('*').off(namespace);
            element.off(namespace);
        }
    } catch (error) {
        console.error('MBlock: Error in event cleanup:', error);
    }
}

/**
 * Check if copy/paste is enabled in configuration
 * @returns {boolean} True if enabled
 */
function checkCopyPasteEnabled() {
    try {
        // Method 1: Check data attribute on any mblock_wrapper
        const $wrapper = $(mblock).first();
        if ($wrapper.length) {
            const copyPasteAttr = $wrapper.attr('data-copy_paste');
            if (copyPasteAttr !== undefined) {
                return (copyPasteAttr === '1' || copyPasteAttr === 'true' || copyPasteAttr === true);
            }
        }
        
        // Method 2: Check for presence of copy/paste buttons in DOM
        const hasCopyButtons = $('.mblock-copy-btn').length > 0;
        const hasToolbar = $('.mblock-copy-paste-toolbar').length > 0;
        
        return hasCopyButtons || hasToolbar;
        
    } catch (error) {
        console.warn('MBlock: Error checking copy/paste configuration:', error);
        return true; // Default: enabled on errors
    }
}

// ‚ú® Modern Smooth Scroll - Use bloecks if available, fallback to vanilla
function mblock_smooth_scroll_to_element(element, options = {}) {
    if (!element) return;
    
    // Try to use bloecks smooth scroll system first
    if (typeof BLOECKS !== 'undefined' && typeof BLOECKS.scrollToSlice === 'function') {
        try {
            BLOECKS.scrollToSlice(element);
            return;
        } catch (error) {
            console.warn('MBlock: Bloecks scroll failed, using fallback:', error);
        }
    }
    
    const config = {
        behavior: 'smooth',
        block: 'center',
        inline: 'nearest',
        offset: -20, // Extra offset from top
        ...options
    };
    
    try {
        // Modern approach with scrollIntoView
        if ('scrollIntoView' in element) {
            // Calculate position with offset
            const elementRect = element.getBoundingClientRect();
            const absoluteElementTop = elementRect.top + window.pageYOffset;
            const scrollToPosition = absoluteElementTop + config.offset;
            
            // Smooth scroll to calculated position
            window.scrollTo({
                top: Math.max(0, scrollToPosition),
                behavior: config.behavior
            });
        } else {
            // Fallback for very old browsers
            element.scrollIntoView({
                behavior: config.behavior,
                block: config.block,
                inline: config.inline
            });
        }
    } catch (error) {
        // Ultimate fallback
        try {
            element.scrollIntoView();
        } catch (fallbackError) {
            console.warn('MBlock: Smooth scroll not available:', fallbackError);
        }
    }
}

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockUtils, mblock_show_message, mblock_get_text, mblock_validate_element };
}

// ==================== WIDGETS.JS ====================
/**
 * MBlock Widgets - Widget-specific code and reinitialization
 * 
 * Contains:
 * - REDAXO Media and Link widget handling
 * - Selectpicker and form widget utilities
 * - Widget reinitialization for new blocks
 * - REX field processing and validation
 * 
 * @author joachim doerr
 * @version 2.0  
 */

// Widget-specific utilities and handlers
const MBlockWidgets = {
    
    // REX Media widget utilities
    media: {
        /**
         * Capture REX_MEDIA widget data for clipboard
         * @param {jQuery} container - Container with media widgets
         * @param {Object} formData - Form data object to populate
         */
        captureData(container, formData) {
            // REX_MEDIA widgets
            container.find('input[id^="REX_MEDIA_"]').each(function() {
                const $hiddenInput = $(this);
                const hiddenId = $hiddenInput.attr('id');
                const name = $hiddenInput.attr('name');
                
                if (hiddenId && !hiddenId.includes('_NAME') && $hiddenInput.attr('type') === 'hidden') {
                    const mediaFileName = $hiddenInput.val();
                    const displayId = hiddenId + '_NAME';
                    const $displayInput = $('#' + displayId);
                    
                    formData[name] = {
                        type: 'rex_media',
                        value: mediaFileName,
                        hiddenId: hiddenId,
                        displayId: displayId,
                        displayValue: $displayInput.length ? $displayInput.val() : '',
                        buttonOnclicks: {}
                    };
                    
                    // Capture media widget button onclick attributes
                    const $mediaContainer = $hiddenInput.closest('.input-group, .rex-js-widget-media');
                    if ($mediaContainer.length) {
                        $mediaContainer.find('.btn-popup').each(function(index) {
                            const $btn = $(this);
                            const onclick = $btn.attr('onclick');
                            if (onclick) {
                                formData[name].buttonOnclicks['btn_' + index] = onclick;
                            }
                        });
                    }
                }
            });
        },

        /**
         * Restore REX_MEDIA widget data after paste
         * @param {jQuery} pastedItem - Pasted item container
         * @param {Object} fieldData - Field data to restore
         * @param {jQuery} $field - Field element
         */
        restoreData(pastedItem, fieldData, $field) {
            if (fieldData.value !== undefined) {
                $field.val(fieldData.value);
                
                // Find and restore display field
                const $displayField = pastedItem.find('#' + fieldData.displayId);
                if (!$displayField.length) {
                    // Fallback: find by pattern matching if ID changed
                    const fieldId = $field.attr('id');
                    if (fieldId) {
                        const $displayFieldFallback = pastedItem.find('#' + fieldId + '_NAME');
                        if ($displayFieldFallback.length && fieldData.displayValue) {
                            $displayFieldFallback.val(fieldData.displayValue);
                        }
                    }
                } else {
                    if (fieldData.displayValue) {
                        $displayField.val(fieldData.displayValue);
                    }
                }
                
                // Restore button onclick handlers
                if (fieldData.buttonOnclicks) {
                    const $mediaContainer = $field.closest('.input-group, .rex-js-widget-media');
                    if ($mediaContainer.length) {
                        $mediaContainer.find('.btn-popup').each(function(index) {
                            const $btn = $(this);
                            const onclickKey = 'btn_' + index;
                            if (fieldData.buttonOnclicks[onclickKey]) {
                                let onclick = fieldData.buttonOnclicks[onclickKey];
                                
                                // Update REX_MEDIA IDs in onclick handlers
                                const newFieldId = $field.attr('id');
                                if (newFieldId && fieldData.hiddenId !== newFieldId) {
                                    onclick = onclick.replace(new RegExp(fieldData.hiddenId, 'g'), newFieldId);
                                    
                                    // Also update numeric part for deleteREXMedia calls
                                    const oldNumericId = fieldData.hiddenId.replace('REX_MEDIA_', '');
                                    const newNumericId = newFieldId.replace('REX_MEDIA_', '');
                                    onclick = onclick.replace(new RegExp("'" + oldNumericId + "'", 'g'), "'" + newNumericId + "'");
                                }
                                
                                $btn.attr('onclick', onclick);
                            }
                        });
                    }
                }
            }
        },

        /**
         * Reinitialize REX_MEDIA widgets in container
         * @param {jQuery} container - Container with media widgets
         * @param {boolean} isGridBlock - Whether this is a GridBlock context
         */
        reinitialize(container, isGridBlock = false) {
            container.find('input[id^="REX_MEDIA_"]').each(function() {
                const $input = $(this);
                const inputId = $input.attr('id');
                const inputName = $input.attr('name');
                
                if (inputId) {
                    console.log('MBlock: Reinitialisiere REX_MEDIA Widget:', inputId, 'Name:', inputName);
                    
                    // Find media widget container - try multiple selectors
                    let $widget = $input.closest('.rex-js-widget-media');
                    if (!$widget.length) {
                        $widget = $input.closest('.form-group, .col-sm-10, .input-group');
                    }
                    
                    if ($widget.length) {
                        // Find all media buttons
                        const $mediaButtons = $widget.find('.btn-popup, a[onclick*="REXMedia"], a[onclick*="openREXMedia"]');
                        
                        console.log('MBlock: Gefundene Media-Buttons:', $mediaButtons.length);
                        
                        $mediaButtons.each(function() {
                            const $btn = $(this);
                            let onclick = $btn.attr('onclick');
                            
                            if (onclick) {
                                console.log('MBlock: Original onclick:', onclick);
                                
                                // Extract the media ID from the input ID (REX_MEDIA_123456 -> 123456)
                                const mediaIdMatch = inputId.match(/REX_MEDIA_(\d+)/);
                                if (mediaIdMatch) {
                                    const mediaId = mediaIdMatch[1];
                                    let newOnclick = onclick;
                                    
                                    // Update different types of media function calls
                                    if (onclick.includes('openREXMedia')) {
                                        newOnclick = onclick.replace(/openREXMedia\([^,)]+/, `openREXMedia('${mediaId}'`);
                                    } else if (onclick.includes('viewREXMedia')) {
                                        newOnclick = onclick.replace(/viewREXMedia\([^,)]+/, `viewREXMedia('${mediaId}'`);
                                    } else if (onclick.includes('deleteREXMedia')) {
                                        newOnclick = onclick.replace(/deleteREXMedia\([^,)]+/, `deleteREXMedia('${mediaId}'`);
                                    } else if (onclick.includes('addREXMedia')) {
                                        newOnclick = onclick.replace(/addREXMedia\([^,)]+/, `addREXMedia('${mediaId}'`);
                                    }
                                    // GridBlock-specific patterns
                                    else if (onclick.includes('openMedia')) {
                                        newOnclick = onclick.replace(/openMedia\([^,)]+/, `openMedia('${mediaId}'`);
                                    } else if (onclick.includes('deleteMedia')) {
                                        newOnclick = onclick.replace(/deleteMedia\([^,)]+/, `deleteMedia('${mediaId}'`);
                                    }
                                    
                                    if (newOnclick !== onclick) {
                                        $btn.attr('onclick', newOnclick);
                                        console.log('MBlock: Aktualisiert onclick:', newOnclick);
                                    }
                                }
                            }
                        });
                        
                        // GridBlock-specific: Update data attributes if present
                        if (isGridBlock) {
                            const $preview = $widget.find('.rex-media-preview, [data-media-id]');
                            if ($preview.length) {
                                const mediaValue = $input.val();
                                if (mediaValue) {
                                    $preview.attr('data-media-id', mediaValue);
                                    console.log('MBlock: GridBlock Media-Preview aktualisiert:', mediaValue);
                                }
                            }
                        }
                    } else {
                        console.warn('MBlock: Kein Media-Widget-Container gefunden f√ºr:', inputId);
                    }
                }
            });
        }
    },

    // REX Link widget utilities
    link: {
        /**
         * Capture REX_LINK widget data for clipboard
         * @param {jQuery} container - Container with link widgets
         * @param {Object} formData - Form data object to populate
         */
        captureData(container, formData) {
            // REX_LINK widgets (comprehensive handling)
            container.find('input[id^="REX_LINK_"]').each(function() {
                const $hiddenInput = $(this);
                const hiddenId = $hiddenInput.attr('id');
                const name = $hiddenInput.attr('name');
                
                // Only process hidden inputs (not the _NAME display inputs)
                if (hiddenId && !hiddenId.includes('_NAME') && $hiddenInput.attr('type') === 'hidden') {
                    const articleId = $hiddenInput.val();
                    const displayId = hiddenId + '_NAME';
                    const $displayInput = $('#' + displayId);
                    
                    formData[name] = {
                        type: 'rex_link',
                        value: articleId,
                        hiddenId: hiddenId,
                        displayId: displayId,
                        displayValue: $displayInput.length ? $displayInput.val() : '',
                        // Store onclick attributes from buttons for later restoration
                        buttonOnclicks: {}
                    };
                    
                    // Capture button onclick attributes
                    const $linkContainer = $hiddenInput.closest('.input-group');
                    if ($linkContainer.length) {
                        $linkContainer.find('.btn-popup').each(function(index) {
                            const $btn = $(this);
                            const onclick = $btn.attr('onclick');
                            if (onclick) {
                                formData[name].buttonOnclicks['btn_' + index] = onclick;
                            }
                        });
                    }
                }
            });
        },

        /**
         * Restore REX_LINK widget data after paste
         * @param {jQuery} pastedItem - Pasted item container
         * @param {Object} fieldData - Field data to restore
         * @param {jQuery} $field - Field element
         */
        restoreData(pastedItem, fieldData, $field) {
            if (fieldData.value !== undefined) {
                $field.val(fieldData.value);
                
                // Find and restore display field
                const $displayField = pastedItem.find('#' + fieldData.displayId);
                if (!$displayField.length) {
                    // Fallback: find by pattern matching if ID changed
                    const fieldId = $field.attr('id');
                    if (fieldId) {
                        const $displayFieldFallback = pastedItem.find('#' + fieldId + '_NAME');
                        if ($displayFieldFallback.length) {
                            if (fieldData.displayValue) {
                                $displayFieldFallback.val(fieldData.displayValue);
                            } else if (fieldData.value) {
                                // Auto-fetch article name if display value is missing
                                MBlockWidgets.link.fetchArticleName(fieldData.value, $displayFieldFallback);
                            }
                        }
                    }
                } else {
                    if (fieldData.displayValue) {
                        $displayField.val(fieldData.displayValue);
                    } else if (fieldData.value) {
                        // Auto-fetch article name if display value is missing
                        MBlockWidgets.link.fetchArticleName(fieldData.value, $displayField);
                    }
                }
                
                // Restore button onclick handlers
                if (fieldData.buttonOnclicks) {
                    const $linkContainer = $field.closest('.input-group');
                    if ($linkContainer.length) {
                        $linkContainer.find('.btn-popup').each(function(index) {
                            const $btn = $(this);
                            const onclickKey = 'btn_' + index;
                            if (fieldData.buttonOnclicks[onclickKey]) {
                                let onclick = fieldData.buttonOnclicks[onclickKey];
                                
                                // Update REX_LINK IDs in onclick handlers
                                const newFieldId = $field.attr('id');
                                if (newFieldId && fieldData.hiddenId !== newFieldId) {
                                    onclick = onclick.replace(new RegExp(fieldData.hiddenId, 'g'), newFieldId);
                                    
                                    // Also update numeric part for deleteREXLink calls
                                    const oldNumericId = fieldData.hiddenId.replace('REX_LINK_', '');
                                    const newNumericId = newFieldId.replace('REX_LINK_', '');
                                    onclick = onclick.replace(new RegExp("'" + oldNumericId + "'", 'g'), "'" + newNumericId + "'");
                                }
                                
                                $btn.attr('onclick', onclick);
                            }
                        });
                    }
                }
            }
        },

        /**
         * Reinitialize REX_LINK widgets in container
         * @param {jQuery} container - Container with link widgets
         * @param {boolean} isGridBlock - Whether this is a GridBlock context
         */
        reinitialize(container, isGridBlock = false) {
            container.find('input[id^="REX_LINK_"]').each(function() {
                const $input = $(this);
                const inputId = $input.attr('id');
                const inputName = $input.attr('name');
                
                // Only process hidden inputs (not the _NAME display inputs)
                if (inputId && !inputId.includes('_NAME') && $input.attr('type') === 'hidden') {
                    console.log('MBlock: Reinitialisiere REX_LINK Widget:', inputId, 'Name:', inputName);
                    
                    // Find link widget container
                    let $widget = $input.closest('.rex-js-widget-link, .form-group, .input-group');
                    if (!$widget.length) {
                        $widget = $input.parent();
                    }
                    
                    if ($widget.length) {
                        // Find all link buttons
                        const $linkButtons = $widget.find('.btn-popup, a[onclick*="REXLink"], a[onclick*="openLinkMap"]');
                        
                        console.log('MBlock: Gefundene Link-Buttons:', $linkButtons.length);
                        
                        $linkButtons.each(function() {
                            const $btn = $(this);
                            let onclick = $btn.attr('onclick');
                            
                            if (onclick) {
                                console.log('MBlock: Original Link onclick:', onclick);
                                
                                // Extract the link ID from the input ID (REX_LINK_123456 -> 123456)
                                const linkIdMatch = inputId.match(/REX_LINK_(\d+)/);
                                if (linkIdMatch) {
                                    const linkId = linkIdMatch[1];
                                    let newOnclick = onclick;
                                    
                                    // Update different types of link function calls
                                    if (onclick.includes('openLinkMap')) {
                                        newOnclick = onclick.replace(/openLinkMap\([^,)]+/, `openLinkMap('${inputId}'`);
                                    } else if (onclick.includes('deleteREXLink')) {
                                        newOnclick = onclick.replace(/deleteREXLink\([^,)]+/, `deleteREXLink('${linkId}'`);
                                    }
                                    // GridBlock-specific patterns
                                    else if (onclick.includes('openLink')) {
                                        newOnclick = onclick.replace(/openLink\([^,)]+/, `openLink('${inputId}'`);
                                    } else if (onclick.includes('deleteLink')) {
                                        newOnclick = onclick.replace(/deleteLink\([^,)]+/, `deleteLink('${linkId}'`);
                                    }
                                    
                                    if (newOnclick !== onclick) {
                                        $btn.attr('onclick', newOnclick);
                                        console.log('MBlock: Aktualisiert Link onclick:', newOnclick);
                                    }
                                }
                            }
                        });
                        
                        // Auto-populate display field if empty
                        const displayId = inputId + '_NAME';
                        const $displayField = container.find('#' + displayId);
                        const articleId = $input.val();
                        
                        if ($displayField.length && articleId && !$displayField.val()) {
                            console.log('MBlock: Auto-populate Link display field for:', displayId);
                            MBlockWidgets.link.fetchArticleName(articleId, $displayField);
                        }
                    }
                }
            });
        },

        /**
         * AJAX function to fetch article name for REX_LINK fields
         * @param {string} articleId - Article ID to fetch name for
         * @param {jQuery} $displayField - Display field to populate
         */
        fetchArticleName(articleId, $displayField) {
            if (!articleId || !$displayField || !$displayField.length) return;
            
            // Cache for already loaded article names
            if (!window.mblock_article_cache) {
                window.mblock_article_cache = {};
            }
            
            // Use from cache if available
            if (window.mblock_article_cache[articleId]) {
                $displayField.val(window.mblock_article_cache[articleId]);
                console.log('MBlock: Artikel-Name aus Cache:', window.mblock_article_cache[articleId], 'f√ºr ID:', articleId);
                return;
            }
            
            // AJAX request to REDAXO Structure Linkmap
            const currentClang = $('input[name="clang"]').val() || 1;
            const ajaxUrl = rex.backend + '?page=structure/linkmap&opener_input_field=temp&article_id=' + articleId + '&clang=' + currentClang;
            
            $.ajax({
                url: ajaxUrl,
                method: 'GET',
                timeout: 5000,
                success: function(response) {
                    // Extract article name from response
                    let articleName = '';
                    
                    // Try different patterns
                    const patterns = [
                        /<a[^>]+onclick="[^"]*selectLink[^"]*"[^>]*>([^<]+)</gi,
                        /<span[^>]*class="[^"]*article[^"]*"[^>]*>([^<]+)</gi,
                        /article_name['"]*:\s*['"]([^'"]+)['"]/gi,
                        /"name"\s*:\s*"([^"]+)"/gi
                    ];
                    
                    for (const pattern of patterns) {
                        const match = pattern.exec(response);
                        if (match && match[1] && match[1].trim()) {
                            articleName = match[1].trim();
                            break;
                        }
                    }
                    
                    // Fallback: use ID with article prefix
                    if (!articleName) {
                        articleName = 'Artikel [' + articleId + ']';
                    }
                    
                    // Store in cache and set display field
                    window.mblock_article_cache[articleId] = articleName;
                    $displayField.val(articleName);
                    $displayField.trigger('change');
                    
                    console.log('MBlock: Artikel-Name per AJAX geholt:', articleName, 'f√ºr ID:', articleId);
                },
                error: function() {
                    // Fallback on AJAX error
                    const fallbackName = 'Artikel [' + articleId + ']';
                    window.mblock_article_cache[articleId] = fallbackName;
                    $displayField.val(fallbackName);
                    
                    console.log('MBlock: Artikel-Name Fallback verwendet:', fallbackName, 'f√ºr ID:', articleId);
                }
            });
        }
    },

    // Selectpicker utilities
    selectpicker: {
        /**
         * Convert selectpicker elements back to plain select elements
         * @param {jQuery} container - Container with selectpicker elements
         */
        convertToPlain(container) {
            try {
                // Find all select elements that have selectpicker class or are inside bootstrap-select wrappers
                const $selectElements = container.find('select.selectpicker, .bootstrap-select select');
                
                $selectElements.each(function() {
                    const $select = $(this);
                    
                    // Store current value
                    const selectedValue = $select.val();
                    
                    // Create clean select element
                    const $cleanSelect = $select.clone();
                    
                    // Remove ALL selectpicker and bootstrap-select related classes and attributes
                    $cleanSelect.removeClass('selectpicker bs-select-hidden');
                    $cleanSelect.removeAttr('data-live-search data-live-search-placeholder tabindex aria-describedby');
                    $cleanSelect.removeData(); // Remove all data attributes
                    $cleanSelect.css('display', ''); // Reset any inline styles
                    
                    // Add marker class for later initialization
                    $cleanSelect.addClass('mblock-needs-selectpicker');
                    
                    // Restore selected value
                    $cleanSelect.val(selectedValue);
                    
                    // Find the outermost bootstrap-select wrapper(s) around this select
                    const $bootstrapWrappers = $select.parents('.bootstrap-select');
                    
                    if ($bootstrapWrappers.length > 0) {
                        // Replace the outermost wrapper with our clean select
                        const $outermostWrapper = $bootstrapWrappers.last();
                        $outermostWrapper.replaceWith($cleanSelect);
                    } else {
                        // If no wrapper, just replace the select itself
                        $select.replaceWith($cleanSelect);
                    }
                });
                
                // Clean up any remaining empty bootstrap-select containers
                container.find('.bootstrap-select').each(function() {
                    const $wrapper = $(this);
                    if (!$wrapper.find('select').length) {
                        $wrapper.remove();
                    }
                });
                
            } catch (error) {
                console.error('MBlock: Error converting selectpicker to plain select:', error);
            }
        },

        /**
         * Initialize selectpicker on elements
         * @param {jQuery} container - Container with elements to initialize
         */
        initialize(container) {
            if (typeof $.fn.selectpicker === 'function') {
                var selects = container.find('select.mblock-needs-selectpicker');
                if (selects.length) {
                    selects.removeClass('mblock-needs-selectpicker').addClass('selectpicker');
                    selects.selectpicker({ noneSelectedText: '‚Äî' });
                    selects.selectpicker('refresh');
                }
            }
        }
    },

    // General widget reinitialization
    /**
     * Critical function to reinitialize REDAXO Media and Link widgets in new blocks
     * This fixes the issue where media/link selection doesn't work in dynamically added blocks
     * @param {jQuery} container - Container with widgets to reinitialize
     */
    reinitializeAll(container) {
        try {
            if (!container || !container.length) {
                return false;
            }
            
            // Get context information
            const mblockIndex = parseInt(container.attr('data-mblock_index')) || 1;
            const mblockWrapper = container.closest('.mblock_wrapper');
            const mblockCount = mblockWrapper.find('.sortitem').length || 1;
            const isGridBlock = MBlockAddonFixes.gridblock.isGridBlock(container);
            
            console.log('MBlock: Widget-Reinitialisierung gestartet', {
                mblockIndex: mblockIndex,
                isGridBlock: isGridBlock,
                containerClass: container.attr('class')
            });
            
            // Reinitialize REX Media widgets
            this.media.reinitialize(container, isGridBlock);
            
            // Reinitialize REX Link widgets  
            this.link.reinitialize(container, isGridBlock);
            
            // REX LINKLIST widgets
            container.find('input[id^="REX_LINKLIST_"]').each(function() {
                const $input = $(this);
                const inputId = $input.attr('id');
                
                if (inputId) {
                    console.log('MBlock: Reinitialisiere REX_LINKLIST Widget:', inputId);
                    
                    let $widget = $input.closest('.rex-js-widget-linklist, .form-group');
                    if (!$widget.length) {
                        $widget = $input.parent();
                    }
                    
                    if ($widget.length) {
                        // Update linklist buttons
                        $widget.find('.btn-popup, a[onclick*="openLinklistMap"]').each(function() {
                            const $btn = $(this);
                            let onclick = $btn.attr('onclick');
                            
                            if (onclick && onclick.includes('openLinklistMap')) {
                                const newOnclick = onclick.replace(/openLinklistMap\([^,)]+/, `openLinklistMap('${inputId}'`);
                                if (newOnclick !== onclick) {
                                    $btn.attr('onclick', newOnclick);
                                    console.log('MBlock: Aktualisiert Linklist onclick:', newOnclick);
                                }
                            }
                        });
                    }
                }
            });
            
            // GridBlock-specific: Trigger rex:ready event for custom widgets
            if (isGridBlock) {
                console.log('MBlock: GridBlock erkannt - triggere rex:ready Event');
                
                // Trigger rex:ready specifically for GridBlock
                container.trigger('rex:ready', [container]);
                
                // Also trigger on individual form elements
                container.find('input, select, textarea').trigger('rex:ready');
                
                // GridBlock-specific media widget reinitialization
                if (typeof window.gridblock_reinit_widgets === 'function') {
                    window.gridblock_reinit_widgets(container);
                }
                
                // Try to reinitialize selectpicker in GridBlock context
                setTimeout(() => {
                    this.selectpicker.initialize(container);
                }, 100);
            }
            
            // General widget reinitialization
            setTimeout(() => {
                // Trigger rex:ready event for general REDAXO widget initialization
                container.trigger('rex:ready', [container]);
                
                // Also trigger change events to ensure proper widget state
                container.find('input, select, textarea').trigger('change');
                
                console.log('MBlock: Rex:ready events getriggert');
            }, 50);
            
            console.log('MBlock: REDAXO widgets erfolgreich reinitialisiert f√ºr', isGridBlock ? 'GridBlock' : 'Standard MBlock');
            
            return true;
            
        } catch (error) {
            console.error('MBlock: Fehler bei der Reinitialisierung der REDAXO Widgets:', error);
            return false;
        }
    }
};

// AUTO-INITIALIZATION: Fill empty REX_LINK display fields on page load
$(document).ready(function() {
    // Wait until REDAXO is fully loaded
    setTimeout(function() {
        MBlockWidgets.link.initializeEmptyFields();
    }, 500);
    
    // TAB-SUPPORT: Initialize REX_LINK fields when tabs are switched
    $(document).on('shown.bs.tab', function(e) {
        // Delay initialization as tab contents need time to become visible
        setTimeout(function() {
            console.log('MBlock: Bootstrap Tab gewechselt - initialisiere REX_LINK-Felder...');
            MBlockWidgets.link.initializeEmptyFields();
        }, 100);
    });
    
    // Alternative for different tab systems (Bootstrap 3/4/5 + MForm)
    $(document).on('click', '.nav-tabs a, .nav-pills a, [data-toggle="tab"], [data-bs-toggle="tab"], .mform-tabs a', function() {
        setTimeout(function() {
            console.log('MBlock: Tab-Click erkannt - initialisiere REX_LINK-Felder...');
            MBlockWidgets.link.initializeEmptyFields();
        }, 200);
    });
    
    // MForm-specific tab events
    $(document).on('mform:tabChanged mform:tabShow', function(e) {
        setTimeout(function() {
            console.log('MBlock: MForm Tab-Event - initialisiere REX_LINK-Felder...');
            MBlockWidgets.link.initializeEmptyFields();
        }, 150);
    });
});

// Extension to link utilities for initialization
MBlockWidgets.link.initializeEmptyFields = function() {
    try {
        console.log('MBlock: Initialisiere leere REX_LINK Display-Felder...');
        let foundFields = 0;
        let processedFields = 0;
        
        // Find all REX_LINK Hidden inputs with values (also in hidden tabs)
        $('input[id^="REX_LINK_"]').each(function() {
            const $hiddenInput = $(this);
            const hiddenId = $hiddenInput.attr('id');
            const articleId = $hiddenInput.val();
            foundFields++;
            
            console.log('MBlock: Pr√ºfe REX_LINK Feld:', hiddenId, 'Wert:', articleId, 'Typ:', $hiddenInput.attr('type'));
            
            // Only process hidden inputs with values (not the _NAME fields)
            if (hiddenId && !hiddenId.includes('_NAME') && 
                $hiddenInput.attr('type') === 'hidden' && 
                articleId && articleId.trim() !== '') {
                
                // Find the corresponding display field
                const displayId = hiddenId + '_NAME';
                const $displayField = $('#' + displayId);
                
                console.log('MBlock: Suche Display-Feld:', displayId, 'gefunden:', $displayField.length, 'aktueller Wert:', $displayField.val());
                
                if ($displayField.length) {
                    const currentDisplayValue = $displayField.val() || '';
                    
                    // Only fill if display field is empty
                    if (currentDisplayValue.trim() === '') {
                        console.log('MBlock: Bef√ºlle leeres REX_LINK Display-Feld:', displayId, 'f√ºr Artikel:', articleId);
                        MBlockWidgets.link.fetchArticleName(articleId, $displayField);
                        processedFields++;
                    } else {
                        console.log('MBlock: Display-Feld bereits bef√ºllt:', displayId, 'Wert:', currentDisplayValue);
                    }
                } else {
                    console.warn('MBlock: Display-Feld nicht gefunden:', displayId, '(m√∂glicherweise in verstecktem Tab)');
                }
            }
        });
        
        console.log('MBlock: REX_LINK Initialisierung abgeschlossen. Gefunden:', foundFields, 'Verarbeitet:', processedFields);
        
    } catch (error) {
        console.error('MBlock: Fehler beim Initialisieren der REX_LINK Display-Felder:', error);
    }
};

// Create global reference for backward compatibility
window.mblock_reinitialize_redaxo_widgets = MBlockWidgets.reinitializeAll.bind(MBlockWidgets);
window.mblock_fetch_article_name = MBlockWidgets.link.fetchArticleName.bind(MBlockWidgets.link);

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockWidgets };
}

// ==================== ADDONFIXES.JS ====================
/**
 * MBlock Addon Fixes - Compatibility fixes for GridBlock and CKEditor5
 * 
 * Contains:
 * - GridBlock compatibility utilities
 * - CKEditor5 specific handling
 * - Nested MBlock initialization fixes
 * - GridBlock widget reinitialization
 * 
 * @author joachim doerr  
 * @version 2.0
 */

// GridBlock and CKE5 specific utilities
const MBlockAddonFixes = {
    
    // GridBlock compatibility utilities
    gridblock: {
        /**
         * Clean up duplicate elements in nested MBlocks (GridBlock compatibility)
         * @param {jQuery} container - Container to clean
         */
        cleanupDuplicates(container) {
            try {
                if (!container || !container.length) return;
                
                container.find('.mblock_wrapper').each(function() {
                    const $wrapper = $(this);
                    
                    // Remove duplicate single-add buttons
                    const $addButtons = $wrapper.find('> .mblock-single-add');
                    if ($addButtons.length > 1) {
                        console.log('MBlock: Removing duplicate single-add buttons');
                        $addButtons.slice(1).remove(); // Keep first, remove rest
                    }
                    
                    // Remove single-add button if there are sortitems
                    const $sortItems = $wrapper.find('> .sortitem');
                    if ($sortItems.length > 0 && $addButtons.length > 0) {
                        console.log('MBlock: Removing single-add button (sortitems exist)');
                        $addButtons.remove();
                    }
                });
            } catch (error) {
                console.error('MBlock: Error cleaning up nested duplicates:', error);
            }
        },

        /**
         * Initialize nested MBlocks safely (GridBlock compatibility)
         * @param {jQuery} container - Container with nested MBlocks
         */
        initializeNested(container) {
            try {
                if (!container || !container.length) return;
                
                container.find('.mblock_wrapper').each(function() {
                    const $nestedWrapper = $(this);
                    if ($nestedWrapper.length) {
                        // Clean up first
                        MBlockAddonFixes.gridblock.cleanupDuplicates($nestedWrapper.parent());
                        
                        // Reset initialization flag
                        $nestedWrapper.removeData('mblock_run');
                        
                        // Initialize
                        console.log('MBlock: Safe initialization of nested wrapper');
                        mblock_init($nestedWrapper);
                    }
                });
            } catch (error) {
                console.error('MBlock: Error initializing nested MBlocks:', error);
            }
        },

        /**
         * Check if current context is GridBlock
         * @param {jQuery} container - Container to check
         * @returns {boolean}
         */
        isGridBlock(container) {
            if (!container || !container.length) return false;
            return container.closest('.gridblock_wrapper').length > 0 || container.hasClass('gridblock-item');
        }
    },

    // CKEditor5 specific utilities
    ckeditor: {
        /**
         * Destroy existing CKEditor5 instances before reindexing
         * @param {jQuery} container - Container with editors
         */
        destroyInstances(container) {
            try {
                container.find('.cke5-editor').each(function() {
                    const $textarea = $(this);
                    const editorId = $textarea.attr('id');
                    
                    if (editorId && typeof ckeditors !== 'undefined' && ckeditors[editorId]) {
                        console.log('MBlock: Destroying CKEditor5 instance before reinit:', editorId);
                        try {
                            ckeditors[editorId].destroy();
                            delete ckeditors[editorId];
                        } catch (e) {
                            console.warn('MBlock: Error destroying CKEditor5:', e);
                        }
                    }
                    
                    // Remove CKEditor DOM elements
                    $textarea.next('.ck-editor').remove();
                    $textarea.show(); // Show textarea again
                });
            } catch (error) {
                console.error('MBlock: Error destroying CKEditor5 instances:', error);
            }
        },

        /**
         * Capture CKEditor content for clipboard operations
         * @param {jQuery} container - Container with editors
         * @param {Object} formData - Form data object to populate
         */
        captureContent(container, formData) {
            try {
                // CKEditor content (CKE5)
                container.find('.cke5-editor, textarea[data-cke5-config]').each(function() {
                    const $textarea = $(this);
                    const editorId = $textarea.attr('id');
                    const name = $textarea.attr('name');
                    
                    if (editorId && name) {
                        console.log('MBlock Copy: Processing CKEditor5 field', name, {
                            editorId: editorId,
                            ckeditorsAvailable: typeof ckeditors !== 'undefined',
                            ckeditorInstance: (typeof ckeditors !== 'undefined' && ckeditors[editorId]) ? 'found' : 'not found'
                        });
                        
                        let editorContent = $textarea.val();
                        // Try CKEditor5 first (global ckeditors object)
                        if (editorId && typeof ckeditors !== 'undefined' && ckeditors[editorId]) {
                            try {
                                const editorData = ckeditors[editorId].getData();
                                if (editorData) {
                                    editorContent = editorData;
                                    console.log('MBlock Copy: Got CKEditor5 content:', editorContent.substring(0, 100) + '...');
                                }
                            } catch (e) {
                                console.warn('MBlock Copy: Failed to get CKEditor5 data, using textarea value:', e);
                            }
                        }
                        // Fallback to CKEditor4
                        else if (window.CKEDITOR && window.CKEDITOR.instances[editorId]) {
                            try {
                                const editorData = window.CKEDITOR.instances[editorId].getData();
                                if (editorData) {
                                    editorContent = editorData;
                                    console.log('MBlock Copy: Got CKEditor4 content:', editorContent.substring(0, 100) + '...');
                                }
                            } catch (e) {
                                console.warn('MBlock Copy: Failed to get CKEditor4 data, using textarea value:', e);
                            }
                        }
                        
                        formData[name] = {
                            type: 'ckeditor',
                            value: editorContent,
                            config: {}
                        };
                        
                        // Store important configuration attributes for restoration
                        const configAttrs = ['cke5-config', 'cke5-toolbar', 'cke5-height', 'cke5-readonly'];
                        configAttrs.forEach(attr => {
                            const value = $textarea.attr('data-' + attr);
                            if (value) {
                                formData[name].config[attr] = value;
                            }
                        });
                    }
                });
            } catch (error) {
                console.error('MBlock: Error capturing CKEditor content:', error);
            }
        },

        /**
         * Restore CKEditor content after paste operation
         * @param {jQuery} pastedItem - Pasted item container
         * @param {Object} formData - Form data with editor content
         */
        restoreContent(pastedItem, formData) {
            try {
                Object.keys(formData).forEach(originalName => {
                    const fieldData = formData[originalName];
                    
                    if (!fieldData || typeof fieldData !== 'object') return;
                    if (fieldData.type !== 'ckeditor') return; // Only CKEditor fields
                    
                    // Find field by smart matching
                    let $field = pastedItem.find(`[name="${originalName}"], [name="mblock_new_${originalName}"]`);
                    
                    if (!$field.length || !fieldData.value) return;
                    
                    console.log('MBlock Restore: Processing CKEditor field', originalName, 'with content:', fieldData.value.substring(0, 100) + '...');
                    
                    // Always set the textarea value first
                    $field.val(fieldData.value);
                    
                    // Store the data for later initialization
                    const editorId = $field.attr('id');
                    if (editorId) {
                        console.log('MBlock Restore: Setting up restoration for editor', editorId);
                        
                        // Enhanced restoration with multiple attempts and immediate check
                        const restoreCKE5Content = function(attempt = 0) {
                            const maxAttempts = 15; // Reduced from 25 to 15
                            
                            console.log('MBlock Restore: Attempt', attempt + 1, 'for editor', editorId);
                            
                            // Try CKEditor5 first
                            if (typeof ckeditors !== 'undefined' && ckeditors[editorId]) {
                                try {
                                    ckeditors[editorId].setData(fieldData.value);
                                    console.log('‚úÖ MBlock Restore: CKEditor5 content restored for', editorId);
                                    return;
                                } catch (e) {
                                    console.warn('MBlock Restore: Failed to restore CKEditor5 content:', e);
                                }
                            }
                            // Fallback to CKEditor4
                            else if (window.CKEDITOR && window.CKEDITOR.instances[editorId]) {
                                try {
                                    window.CKEDITOR.instances[editorId].setData(fieldData.value);
                                    console.log('‚úÖ MBlock Restore: CKEditor4 content restored for', editorId);
                                    return;
                                } catch (e) {
                                    console.warn('MBlock Restore: Failed to restore CKEditor4 content:', e);
                                }
                            }
                            
                            // If editor is not ready yet and we haven't exceeded max attempts
                            if (attempt < maxAttempts) {
                                setTimeout(() => restoreCKE5Content(attempt + 1), 300); // Increased delay
                            } else {
                                console.warn('‚ùå MBlock Restore: Timeout restoring content for', editorId, 'after', maxAttempts, 'attempts');
                            }
                        };
                        
                        // Start the restoration process with initial delay
                        setTimeout(() => restoreCKE5Content(0), 100);
                    }
                });
            } catch (error) {
                console.error('MBlock: Error restoring CKEditor content:', error);
            }
        }
    }
};

// CKEditor5 Content Restoration after rex:ready
$(document).on('rex:ready', function(e, container) {
    // Restore CKEditor5 content for pasted items
    container.find('.cke5-editor[data-cke5-restore-content]').each(function() {
        const $editor = $(this);
        const editorId = $editor.attr('id');
        const restoreContent = $editor.attr('data-cke5-restore-content');
        
        if (editorId && restoreContent) {
            console.log('MBlock: Attempting to restore CKEditor5 content for', editorId);
            
            // Wait for CKEditor5 to be fully initialized
            const checkAndRestore = function(attempts = 0) {
                if (attempts > 20) { // Max 4 seconds (20 * 200ms)
                    console.warn('MBlock: Timeout restoring CKEditor5 content for', editorId);
                    $editor.removeAttr('data-cke5-restore-content');
                    return;
                }
                
                if (typeof ckeditors !== 'undefined' && ckeditors[editorId]) {
                    try {
                        ckeditors[editorId].setData(restoreContent);
                        $editor.removeAttr('data-cke5-restore-content');
                        console.log('MBlock: Successfully restored CKEditor5 content for', editorId);
                        return;
                    } catch (e) {
                        console.warn('MBlock: Error setting CKEditor5 data:', e);
                    }
                }
                
                // Try again after a short delay
                setTimeout(() => checkAndRestore(attempts + 1), 200);
            };
            
            // Start checking after a small initial delay
            setTimeout(() => checkAndRestore(), 300);
        }
    });
});

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockAddonFixes };
}

// ==================== MBLOCK-MANAGEMENT.JS ====================
/**
 * MBlock Management - DOM manipulation and sortable handling
 * 
 * Contains:
 * - Sortable management (MBlockSortable)
 * - Item manipulation (add, remove, move)
 * - Reindexing and form element handling
 * - REX field handling
 * - Toolbar functionality
 * 
 * Depends on: mblock-core.js
 * 
 * @author joachim doerr
 * @version 2.0
 */

// üîß Reusable Sortable Management
const MBlockSortable = {
    /**
     * Safely destroy existing sortable instance
     */
    destroy(element) {
        try {
            const domElement = element?.get ? element.get(0) : element;
            if (domElement && domElement._sortable) {
                if (typeof domElement._sortable.destroy === 'function') {
                    domElement._sortable.destroy();
                }
                domElement._sortable = null;
                return true;
            }
        } catch (error) {
            console.warn('MBlock: Sortable destroy error:', error);
            if (element?.get) {
                const domElement = element.get(0);
                if (domElement) domElement._sortable = null;
            }
        }
        return false;
    },

    /**
     * Create new sortable instance with unified configuration
     */
    create(element) {
        try {
            if (!element?.length || !element.get) return false;
            
            const domElement = element.get(0);
            
            if (!document.contains(domElement) || typeof Sortable === 'undefined') {
                return false;
            }

            const sortableInstance = Sortable.create(domElement, {
                handle: '.sorthandle',
                animation: 150,
                ghostClass: 'sortable-ghost',
                chosenClass: 'mblock-sortable-chosen',
                dragClass: 'mblock-dragging',
                
                onStart: (evt) => this._handleStart(evt),
                onEnd: (evt) => this._handleEnd(evt, element),
                onError: (evt) => console.error('MBlock: Sortable Error:', evt)
            });
            
            domElement._sortable = sortableInstance;
            return true;

        } catch (error) {
            console.error('MBlock: Error creating sortable instance:', error);
            return false;
        }
    },

    /**
     * Reinitialize sortable (destroy + create with safety delay)
     */
    reinitialize(element) {
        this.destroy(element);
        setTimeout(() => this.create(element), 10);
    },

    // Private event handlers
    _handleStart(evt) {
        try {
            document.body.classList.add('mblock-drag-active');
            if (evt.item) {
                evt.item.classList.add('mblock-dragging');
            }
        } catch (error) {
            console.error('MBlock: Error in sortable onStart:', error);
        }
    },

    _handleEnd(evt, element) {
        try {
            document.body.classList.remove('mblock-drag-active');
            if (evt.item) {
                evt.item.classList.remove('mblock-dragging');
                MBlockUtils.animation.flashEffect($(evt.item));
            }
            
            mblock_reindex(element);
            mblock_remove(element);
            
            const iClone = $(evt.item);
            if (iClone.length) {
                iClone.trigger('mblock:change', [iClone]);
            }
        } catch (error) {
            console.error('MBlock: Error in sortable onEnd:', error);
        }
    }
};

// Core MBlock functions
$(document).on('rex:ready', function (e, container) {
    try {
        // Initialize clipboard system only if copy/paste is enabled
        const isCopyPasteEnabled = checkCopyPasteEnabled();
        if (isCopyPasteEnabled && typeof MBlockClipboard !== 'undefined') {
            MBlockClipboard.init();
        }
        
        if (container && typeof container.find === 'function') {
            container.find(mblock).each(function () {
                const $element = $(this);
                if ($element.length) {
                    try {
                        // Check if this is a nested initialization to prevent conflicts
                        const isNestedContext = container.closest('.mblock_wrapper').length > 0;
                        if (isNestedContext) {
                            console.log('MBlock: Skipping nested rex:ready initialization (handled by parent)');
                            return;
                        }
                        
                        mblock_init($element);
                    } catch (initError) {
                        console.error('MBlock: Error initializing individual MBlock element:', initError);
                        // Don't let individual errors break the entire initialization
                    }
                }
            });
        } else {
            // Initialize all MBlock elements (global initialization)
            $(mblock).each(function () {
                const $element = $(this);
                if ($element.length) {
                    mblock_init($element);
                }
            });
        }
    } catch (error) {
        console.error('MBlock: Error in rex:ready:', error);
    }
});

function mblock_init(element) {
    try {
        if (!element || !element.length || typeof element.data !== 'function') {
            console.warn('MBlock: Invalid element in mblock_init');
            return false;
        }

        // Check if element is already initialized
        const isAlreadyInitialized = element.data('mblock_run');
        
        if (!isAlreadyInitialized) {
            console.log('MBlock: Initializing new MBlock wrapper');
            element.data('mblock_run', 1);
            mblock_sort(element);
            mblock_set_unique_id(element, false);

            const minValue = element.data('min');
            const maxValue = element.data('max');
            if (minValue == 1 && maxValue == 1) {
                element.addClass('hide_removeadded').addClass('hide_sorthandle');
            }
        } else {
            console.log('MBlock: Reinitializing existing MBlock wrapper - cleaning up first');
            // Remove any duplicate mblock-single-add elements before reinitializing
            element.find('.mblock-single-add').remove();
        }
        
        mblock_add_plus(element);
        mblock_init_toolbar(element);
        
        // Initialize online/offline states if MBlockOnlineToggle is available
        if (typeof MBlockOnlineToggle !== 'undefined') {
            MBlockOnlineToggle.initializeStates(element);
        }
        
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_init:', error);
        return false;
    }
}

// List with handle
function mblock_init_sort(element) {
    try {
        if (!element || !element.length) {
            return false;
        }
        // reindex
        mblock_reindex(element);
        // init
        mblock_sort(element);
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_init_sort:', error);
        return false;
    }
}

function mblock_sort(element) {
    try {
        if (!element || !element.length) {
            return false;
        }
        // add linking
        mblock_add(element);
        // remove mblock_remove
        mblock_remove(element);
        // init sortable
        mblock_sort_it(element);
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_sort:', error);
        return false;
    }
}

function mblock_add_plus(element) {
    // Only add the "add" button if there are no sortitems AND no existing add button
    const hasSortItems = element.find('> div.sortitem').length > 0;
    const hasAddButton = element.find('> div.mblock-single-add').length > 0;
    
    if (!hasSortItems && !hasAddButton) {
        console.log('MBlock: Adding single-add button for empty wrapper');
        element.prepend($($.parseHTML(element.data('mblock-single-add'))));

        element.find('> div.mblock-single-add .addme').unbind().bind('click', function () {
            mblock_add_item(element, false);
            $(this).parents('.mblock-single-add').remove();
        });
    } else if (hasSortItems && hasAddButton) {
        // Remove add button if there are now sortitems (should not happen but safety check)
        console.log('MBlock: Removing unnecessary single-add button (items exist)');
        element.find('> div.mblock-single-add').remove();
    }
}

function mblock_remove(element) {
    var finded = element.find('> div.sortitem');

    if (finded.length == 1) {
        finded.find('.removeme').prop('disabled', true);
        finded.find('.removeme').attr('data-disabled', true);
    } else {
        finded.find('.removeme').prop('disabled', false);
        finded.find('.removeme').attr('data-disabled', false);
    }

    // has data?
    if (element.data().hasOwnProperty('max')) {
        if (finded.length >= element.data('max')) {
            element.find('.addme').prop('disabled', true);
        } else {
            element.find('.addme').prop('disabled', false);
        }
    }

    if (element.data().hasOwnProperty('min')) {
        if (finded.length <= element.data('min')) {
            element.find('.removeme').prop('disabled', true);
        } else {
            element.find('.removeme').prop('disabled', false);
        }
    }

    finded.each(function (index) {
        // min removeme hide
        if ((index + 1) == element.data('min') && finded.length == element.data('min')) {
            $(this).find('.removeme').prop('disabled', true);
        }
        if (index == 0) {
            $(this).find('.moveup').prop('disabled', true);
        } else {
            $(this).find('.moveup').prop('disabled', false);
        }
        if ((index + 1) == finded.length) { // if max count?
            $(this).find('.movedown').prop('disabled', true);
        } else {
            $(this).find('.movedown').prop('disabled', false);
        }
    });
}

function mblock_sort_it(element) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length || !element.get) {
            console.warn('MBlock: Invalid element for mblock_sort_it');
            return false;
        }

        const domElement = element.get(0);
        if (!document.contains(domElement)) {
            console.warn('MBlock: Element no longer in DOM');
            return false;
        }

        // Use centralized sortable management
        if (typeof Sortable !== 'undefined' && Sortable.create) {
            MBlockSortable.reinitialize(element);
            return true;
        } else {
            console.error('MBlock: Sortable.js not available');
            return false;
        }
        
    } catch (error) {
        console.error('MBlock: Error in mblock_sort_it:', error);
        return false;
    }
}

function mblock_reindex(element) {
    try {
        if (!mblock_validate_element(element)) {
            console.warn('MBlock: Invalid element in mblock_reindex');
            return false;
        }

        const mblock_count = element.data('mblock_count') || 0;
        const sortItems = element.find('> div.sortitem');
        
        if (!sortItems.length) {
            return true;
        }

        // Performance optimization: Batch DOM updates
        sortItems.each(function (index) {
            const $sortItem = $(this);
            const sindex = index + 1;
            
            // Set index attribute
            $sortItem.attr('data-mblock_index', sindex);
            
            // Optimized element handling
            mblock_reindex_form_elements($sortItem, index, sindex, mblock_count);
            mblock_reindex_special_elements($sortItem, index, sindex, mblock_count);
        });

        // After reindexing: correct for attributes
        mblock_replace_for(element);
        
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_reindex:', error);
        return false;
    }
}

/**
 * Optimized handling of form elements during reindexing
 */
function mblock_reindex_form_elements($sortItem, index, sindex, mblock_count) {
    try {
        $sortItem.find('input,textarea,select,button').each(function (key) {
            const $element = $(this);
            const eindex = key + 1;
            const attr = $element.attr('name');
            
            // Update name attribute
            if (attr && typeof attr !== 'undefined') {
                const nameMatches = attr.match(/\]\[\d+\]\[/g);
                if (nameMatches) {
                    const newValue = attr.replace(nameMatches, '][' + index + '][').replace('mblock_new_', '');
                    $element.attr('name', newValue);
                }
            }

            // Optimize event handlers for checkboxes
            const elementType = $element.attr('type');
            if (elementType === 'checkbox') {
                $element.off('change.mblock').on('change.mblock', function () {
                    $(this).val($(this).is(':checked') ? 1 : 0);
                });
            }

            // Restore radio button values
            if (elementType === 'radio') {
                const dataValue = $element.attr('data-value');
                if (dataValue) {
                    $element.val(dataValue);
                }
            }

            // Update REX-specific IDs
            mblock_update_rex_ids($element, sindex, mblock_count, eindex);
        });
    } catch (error) {
        console.error('MBlock: Error in mblock_reindex_form_elements:', error);
    }
}

/**
 * Centralized REX-System-ID updater with unified logic
 */
function mblock_update_rex_ids($element, sindex, mblock_count, eindex) {
    try {
        const elementId = $element.attr('id');
        const nodeName = $element.prop('nodeName');
        
        if (!elementId) return;

        // Configuration for different REX field types
        const rexConfigs = [
            {
                type: 'SELECT',
                patterns: ['REX_MEDIALIST_SELECT_', 'REX_LINKLIST_SELECT_'],
                handler: (newId, nameAttr) => {
                    $element.parent().data('eindex', eindex);
                    $element.attr('id', newId);
                    if (nameAttr) {
                        $element.attr('name', nameAttr.replace(/_\d+/, '_' + sindex + mblock_count + '00' + eindex));
                    }
                }
            },
            {
                type: 'INPUT',
                patterns: ['REX_MEDIA_', 'REX_LINKLIST_', 'REX_MEDIALIST_'],
                handler: (newId) => {
                    const parentEindex = $element.parent().data('eindex') || eindex;
                    const actualNewId = elementId.replace(/\d+/, sindex + mblock_count + '00' + parentEindex);
                    $element.attr('id', actualNewId);
                    mblock_update_rex_buttons($element, sindex, mblock_count, parentEindex);
                }
            }
        ];

        // Find matching configuration and apply handler
        const config = rexConfigs.find(cfg => 
            cfg.type === nodeName && 
            cfg.patterns.some(pattern => elementId.indexOf(pattern) >= 0)
        );

        if (config) {
            const newId = elementId.replace(/_\d+/, '_' + sindex + mblock_count + '00' + eindex);
            const nameAttr = $element.attr('name');
            config.handler(newId, nameAttr);
        }

    } catch (error) {
        console.error('MBlock: Error in mblock_update_rex_ids:', error);
    }
}

/**
 * Update REX popup buttons
 */
function mblock_update_rex_buttons($element, sindex, mblock_count, eindex) {
    try {
        const $parent = $element.parent();
        $parent.find('a.btn-popup').each(function () {
            const $btn = $(this);
            const onclick = $btn.attr('onclick');
            if (onclick) {
                const newOnclick = onclick
                    .replace(/\('?\d+/, '(\'' + sindex + mblock_count + '00' + eindex)
                    .replace(/_\d+/, '_' + sindex + mblock_count + '00' + eindex);
                $btn.attr('onclick', newOnclick);
            }
        });
    } catch (error) {
        console.error('MBlock: Error in mblock_update_rex_buttons:', error);
    }
}

/**
 * Handle special elements during reindexing (Bootstrap tabs, accordions, etc.)
 */
function mblock_reindex_special_elements($sortItem, index, sindex, mblock_count) {
    try {
        // Bootstrap Tabs
        $sortItem.find('a[data-toggle="tab"]').each(function (key) {
            const eindex = key + 1;
            const $tab = $(this);
            const href = $tab.attr('href');
            
            if (href) {
                const newHref = href.replace(/_\d+/, '_' + sindex + mblock_count + '00' + eindex);
                $tab.attr('href', newHref);
                
                // Update corresponding tab content
                const $container = $tab.parent().parent().parent().find('.tab-content ' + href);
                if ($container.length) {
                    $container.attr('id', newHref.replace('#', ''));
                }

                // LocalStorage tab handling with error handling
                $tab.off('shown.bs.tab.mblock').on('shown.bs.tab.mblock', function (e) {
                    try {
                        const id = $(e.target).attr('href');
                        if (id && typeof localStorage !== 'undefined') {
                            localStorage.setItem('selectedTab', id);
                        }
                    } catch (storageError) {
                        console.warn('MBlock: LocalStorage not available:', storageError);
                    }
                });
            }
        });

        // Bootstrap Collapse/Accordion
        $sortItem.find('a[data-toggle="collapse"]').each(function (key) {
            const eindex = key + 1;
            const $collapse = $(this);
            
            if (!$collapse.attr('data-ignore-mblock')) {
                const href = $collapse.attr('data-target');
                if (href) {
                    const newHref = href.replace(/_\d+/, '_' + sindex + mblock_count + '00' + eindex);
                    $collapse.attr('data-target', newHref);
                    
                    // Update collapse content
                    const $container = $collapse.parent().find(href);
                    if ($container.length) {
                        $container.attr('id', newHref.replace('#', ''));
                    }
                    
                    // Update group parent if exists
                    const $group = $collapse.parent().parent().parent().find('.panel-group');
                    if ($group.length) {
                        const parentId = 'accgr_' + sindex + mblock_count + '00';
                        $group.attr('id', parentId);
                        $collapse.attr('data-parent', '#' + parentId);
                    }
                }
            }
        });

        // Custom Links (MForm)
        $sortItem.find('.custom-link').each(function (key) {
            const eindex = key + 1;
            const $customlink = $(this);
            
            $customlink.find('input').each(function () {
                const $input = $(this);
                const inputId = $input.attr('id');
                if (inputId) {
                    $input.attr('id', inputId.replace(/\d+/, sindex + mblock_count + '00' + eindex));
                }
            });
            
            $customlink.find('a.btn-popup').each(function () {
                const $btn = $(this);
                const btnId = $btn.attr('id');
                if (btnId) {
                    $btn.attr('id', btnId.replace(/\d+/, sindex + mblock_count + '00' + eindex));
                }
            });
            
            $customlink.attr('data-id', sindex + mblock_count + '00' + eindex);
            
            // Trigger MForm custom link function if available
            if (typeof window.mform_custom_link === 'function') {
                try {
                    window.mform_custom_link($customlink);
                } catch (mformError) {
                    console.warn('MBlock: MForm custom link error:', mformError);
                }
            }
        });
    } catch (error) {
        console.error('MBlock: Error in mblock_reindex_special_elements:', error);
    }
}

function mblock_replace_for(element) {
    element.find('> div.sortitem').each(function (index) {
        var mblock = $(this);
        mblock.find('input:not(:checkbox):not(:radio),textarea,select').each(function (key) {
            var el = $(this),
                id = el.attr('id'),
                name = el.attr('name');
            if ((typeof id !== typeof undefined && id !== false) && (typeof name !== typeof undefined && name !== false)) {
                if (!(id.indexOf("REX_MEDIA") >= 0 ||
                    id.indexOf("REX_LINK") >= 0 ||
                    id.indexOf("redactor") >= 0 ||
                    id.indexOf("markitup") >= 0)
                ) {
                    var label = mblock.find('label[for="' + id + '"]');
                    name = name.replace(/(\[|\])/gm, '');
                    el.attr('id', name);
                    label.attr('for', name);
                }
            }
        });
    });
}

function mblock_add_item(element, item) {
    // create iclone
    const iClone = MBlockUtils.dom.createFromHTML(element.data('mblock-plain-sortitem'));

    // fix for checkbox and radio bug
    iClone.find('input:radio, input:checkbox').each(function () {
        $(this).parent().removeAttr('for');
    });

    // fix radio bug
    iClone.find('input:radio, input:checkbox').each(function () {
        // fix lost checked from parent item
        $(this).attr('name', 'mblock_new_' + $(this).attr('name'));
        // fix lost value
        $(this).attr('data-value', $(this).val());
    });

    if (item === false) {
        // add clone
        element.prepend(iClone);
    } else if (item.parent().hasClass(element.attr('class'))) {
        // Destroy sortable before manipulation
        MBlockSortable.destroy(element);
        
        // add clone
        item.after(iClone);
        // set count
        mblock_set_count(element, item);
    }

    // add unique id
    mblock_set_unique_id(iClone, true);
    // reinit first
    mblock_init_sort(element);
    
    // trigger rex:ready event only on the new item for component initialization
    iClone.trigger('rex:ready', [iClone]);
    
    // CRITICAL: Initialize nested MBlocks BEFORE other components to prevent duplicate initialization
    setTimeout(function() {
        // Use utility function for safe nested MBlock initialization
        if (typeof MBlockUtils.nested !== 'undefined') {
            MBlockUtils.nested.initializeNested(iClone);
        }
        
        // specific component reinitialization
        // Initialize selectpicker with REDAXO core method for new items
        if (typeof $.fn.selectpicker === 'function') {
            var selects = iClone.find('select.selectpicker');
            if (selects.length) {
                selects.selectpicker({
                    noneSelectedText: '‚Äî'
                }).on('rendered.bs.select', function () {
                    $(this).parent().removeClass('bs3-has-addon');
                });
                selects.selectpicker('refresh');
            }
        }
        
        // reinitialize other common components
        if (typeof $.fn.chosen === 'function') {
            iClone.find('select.chosen').chosen();
        }
        
        // CRITICAL FIX: Reinitialize REDAXO Media and Link functionality for new blocks
        if (typeof MBlockWidgets !== 'undefined' && typeof MBlockWidgets.reinitializeAll === 'function') {
            MBlockWidgets.reinitializeAll(iClone);
        }
        
        // trigger change events to update any dependent elements
        iClone.find('input, select, textarea').trigger('change');
    }, 50);
    
    // scroll to item with slight delay to ensure DOM is ready
    setTimeout(function() {
        if (iClone && iClone.length && iClone.is(':visible')) {
            mblock_scroll(element, iClone);
        }
    }, 100);
}

function mblock_set_unique_id(item, input_delete) {
    try {
        if (!item || !item.length || typeof item.find !== 'function') {
            console.warn('MBlock: Invalid item in mblock_set_unique_id');
            return false;
        }

        item.find('input').each(function () {
            try {
                const $input = $(this);
                const isUniqueInt = $input.attr('data-unique-int') == 1;
                const isUnique = $input.attr('data-unique') == 1 || isUniqueInt;
                
                if (isUnique) {
                    let unique_id;
                    if (isUniqueInt) {
                        unique_id = Math.floor(Math.random() * 1000000000000);
                    } else {
                        unique_id = Math.random().toString(16).slice(2);
                    }

                    if (input_delete === true) {
                        $input.val('');
                    }
                    if ($input.val() === '' || $input.val() === null) {
                        $input.val(unique_id);
                    }
                }
            } catch (error) {
                console.error('MBlock: Error in unique_id generation:', error);
            }
        });
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_set_unique_id:', error);
        return false;
    }
}

function mblock_set_count(element, item) {
    var countItem = item.next().find('span.mb_count'),
        count = element.find('> div.sortitem').length;

    if (element.data('latest')) {
        count = element.data('latest') + 1;
    }

    countItem.text(count);
    element.data('latest', count);
}

function mblock_remove_item(element, item) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length || !item || !item.length) {
            console.warn('MBlock: Invalid parameters in mblock_remove_item');
            return false;
        }

        const elementData = element.data();
        if (elementData && elementData.hasOwnProperty('delete_confirm')) {
            if (!confirm(elementData.delete_confirm)) {
                return false;
            }
        }

        const itemParent = item.parent();
        const elementClass = element.attr('class');
        
        if (itemParent.length && elementClass && itemParent.hasClass(elementClass)) {
            // Destroy sortable before manipulation
            MBlockSortable.destroy(element);

            // set prev item
            let prevItem = item.prev();
            // is prev exist?
            if (!prevItem.length || !prevItem.hasClass('sortitem')) {
                prevItem = item.next(); // go to next
            }

            // Safe element removal with event cleanup using utilities
            if (MBlockUtils.dom.safeRemove(item)) {
                // reinit
                mblock_init_sort(element);
                // scroll to item (if a previous element exists)
                if (prevItem && prevItem.length) {
                    mblock_scroll(element, prevItem);
                }
                // add add button
                mblock_add_plus(element);
                return true;
            } else {
                console.error('MBlock: Error removing item');
                return false;
            }
        }
        
        return false;
    } catch (error) {
        console.error('MBlock: Error in mblock_remove_item:', error);
        return false;
    }
}

function mblock_moveup(element, item) {
    var prev = item.prev();
    if (prev.length == 0) return;

    setTimeout(function () {
        item.insertBefore(prev);
        // set last user action
        mblock_reindex(element);
        mblock_remove(element);
        // trigger event
        let iClone = prev;
        iClone.trigger('mblock:change', [iClone]);
    }, 150);
}

function mblock_movedown(element, item) {
    var next = item.next();
    if (next.length == 0) return;

    setTimeout(function () {
        item.insertAfter(next);
        // set last user action
        mblock_reindex(element);
        mblock_remove(element);
        // trigger event
        let iClone = next;
        iClone.trigger('mblock:change', [iClone]);
    }, 150);
}

function mblock_scroll(element, item) {
    try {
        if (!element || !element.length || !item || !item.length) {
            return false;
        }

        const elementData = element.data();
        
        // If smooth_scroll is enabled, use the smooth scroll function
        if (elementData && elementData.hasOwnProperty('smooth_scroll') && elementData.smooth_scroll === true) {
            if (typeof $.mblockSmoothScroll === 'function') {
                $.mblockSmoothScroll({
                    scrollTarget: item,
                    speed: 500
                });
                return true;
            }
        }
        
        // Fallback: Standard browser scrolling to the element
        if (item.length && item.offset()) {
            const itemOffset = item.offset().top;
            const windowHeight = $(window).height();
            const scrollTop = $(window).scrollTop();
            
            // Only scroll if element is not already visible
            if (itemOffset < scrollTop || itemOffset > (scrollTop + windowHeight - 200)) {
                $('html, body').animate({
                    scrollTop: itemOffset - 100 // 100px distance from top
                }, 300);
            }
        }
        
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_scroll:', error);
        return false;
    }
}

function mblock_add(element) {
    try {
        if (!MBlockUtils.is.validElement(element) || !element.length) {
            console.warn('MBlock: Invalid element in mblock_add');
            return false;
        }

        // Centralized event handler configuration
        const eventHandlers = [
            {
                selector: MBlockUtils.selectors.addme,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        const $this = $(this);
                        if (!MBlockUtils.state.isDisabled($this)) {
                            const $item = $this.parents('.sortitem');
                            const itemIndex = $item.attr('data-mblock_index');
                            if (itemIndex) {
                                element.attr('data-mblock_clicked_add_item', itemIndex);
                            }
                            mblock_add_item(element, $this.closest('div[class^="sortitem"]'));
                        }
                    } catch (error) {
                        console.error('MBlock: Error in addme click handler:', error);
                    }
                    return false;
                }
            },
            {
                selector: MBlockUtils.selectors.removeme,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        const $this = $(this);
                        if (!MBlockUtils.state.isDisabled($this)) {
                            mblock_remove_item(element, $this.closest('div[class^="sortitem"]'));
                        }
                    } catch (error) {
                        console.error('MBlock: Error in removeme click handler:', error);
                    }
                    return false;
                }
            },
            {
                selector: MBlockUtils.selectors.moveup,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        const $this = $(this);
                        if (!MBlockUtils.state.isDisabled($this)) {
                            mblock_moveup(element, $this.closest('div[class^="sortitem"]'));
                        }
                    } catch (error) {
                        console.error('MBlock: Error in moveup click handler:', error);
                    }
                    return false;
                }
            },
            {
                selector: MBlockUtils.selectors.movedown,
                event: 'click',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        const $this = $(this);
                        if (!MBlockUtils.state.isDisabled($this)) {
                            mblock_movedown(element, $this.closest('div[class^="sortitem"]'));
                        }
                    } catch (error) {
                        console.error('MBlock: Error in movedown click handler:', error);
                    }
                    return false;
                }
            }
        ];

        // Bind all basic event handlers
        eventHandlers.forEach(({selector, event, handler}) => {
            const elements = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${selector}`);
            MBlockUtils.events.bindSafe(elements, event, handler);
        });

        // Handle copy/paste buttons only if enabled
        if (checkCopyPasteEnabled()) {
            mblock_add._bindCopyPasteHandlers(element);
        }

        // Handle online/offline toggle buttons
        mblock_add._bindToggleHandlers(element);

        // Initialize states
        if (checkCopyPasteEnabled() && typeof MBlockClipboard !== 'undefined') {
            MBlockClipboard.updatePasteButtons();
        }
        if (typeof MBlockOnlineToggle !== 'undefined') {
            MBlockOnlineToggle.initializeStates(element);
        }

        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_add:', error);
        return false;
    }
}

// Private helper methods for mblock_add
mblock_add._bindCopyPasteHandlers = function(element) {
    // Copy Button Handler
    const copyButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.copyBtn}`);
    if (copyButtons.length > 0) {
        MBlockUtils.events.bindSafe(copyButtons, 'click', function (e) {
            e.preventDefault();
            try {
                const $this = $(this);
                const $item = $this.closest('div[class^="sortitem"]');
                if (typeof MBlockClipboard !== 'undefined') {
                    MBlockClipboard.copy(element, $item);
                }
            } catch (error) {
                console.error('MBlock: Error in copy click handler:', error);
            }
            return false;
        });
    }

    // Paste Button Handler
    const pasteButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.pasteBtn}`);
    if (pasteButtons.length > 0) {
        MBlockUtils.events.bindSafe(pasteButtons, 'click', function (e) {
            e.preventDefault();
            try {
                const $this = $(this);
                if (!MBlockUtils.state.isDisabled($this)) {
                    const $item = $this.closest('div[class^="sortitem"]');
                    if (typeof MBlockClipboard !== 'undefined') {
                        MBlockClipboard.paste(element, $item);
                    }
                }
            } catch (error) {
                console.error('MBlock: Error in paste click handler:', error);
            }
            return false;
        });
    }
};

mblock_add._bindToggleHandlers = function(element) {
    // Online/Offline Toggle Handler (old system)
    const toggleButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.onlineToggle}`);
    MBlockUtils.events.bindSafe(toggleButtons, 'click', function (e) {
        e.preventDefault();
        try {
            const $this = $(this);
            const $item = $this.closest('div[class^="sortitem"]');
            if (typeof MBlockOnlineToggle !== 'undefined') {
                MBlockOnlineToggle.toggle(element, $item);
            }
        } catch (error) {
            console.error('MBlock: Error in online/offline toggle handler:', error);
        }
        return false;
    });

    // New Auto-Detected Toggle Handler
    const autoToggleButtons = MBlockUtils.dom.findElement(element, `${MBlockUtils.selectors.sortitem} ${MBlockUtils.selectors.autoToggle}`);
    MBlockUtils.events.bindSafe(autoToggleButtons, 'click', function (e) {
        e.preventDefault();
        try {
            const $this = $(this);
            const $item = $this.closest('div[class^="sortitem"]');
            if (typeof MBlockOnlineToggle !== 'undefined') {
                MBlockOnlineToggle.toggleAutoDetected(element, $item, $this);
            }
        } catch (error) {
            console.error('MBlock: Error in auto-detected toggle handler:', error);
        }
        return false;
    });
};

// Initialize toolbar functionality
function mblock_init_toolbar(element) {
    try {
        if (!element || !element.length) {
            return false;
        }
        
        // Initialize toolbar elements if they exist
        const $toolbar = element.find('.mblock-toolbar');
        if ($toolbar.length) {
            console.log('MBlock: Initializing toolbar for element');
            // Add any toolbar-specific initialization here
        }
        
        return true;
    } catch (error) {
        console.error('MBlock: Error in mblock_init_toolbar:', error);
        return false;
    }
}

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockSortable };
}

// ==================== MBLOCK-FEATURES.JS ====================
/**
 * MBlock Features - Advanced functionality
 * 
 * Contains:
 * - Copy/Paste functionality (MBlockClipboard)
 * - Online/Offline toggle (MBlockOnlineToggle)
 * - Advanced features and toolbar functionality
 * 
 * Depends on: mblock-core.js, mblock-management.js, widgets.js, addonfixes.js
 * 
 * @author joachim doerr
 * @version 2.0
 */

// Copy & Paste functionality with Session/Local Storage
var MBlockClipboard = {
    data: null,
    storageKey: 'mblock_clipboard',
    useSessionStorage: true, // true = Session Storage, false = Local Storage
    
    // Initialize clipboard from storage
    init: function() {
        try {
            const loaded = this.loadFromStorage();
            if (this.data) {
                // Clipboard data loaded
            }
        } catch (error) {
            console.warn('MBlock: Error initializing clipboard:', error);
        }
    },
    
    // Get storage object (sessionStorage or localStorage)
    getStorage: function() {
        try {
            return this.useSessionStorage ? sessionStorage : localStorage;
        } catch (e) {
            console.warn('MBlock: Storage not available, using memory fallback');
            return null;
        }
    },
    
    // Load data from storage
    loadFromStorage: function() {
        try {
            const storage = this.getStorage();
            if (!storage) return false;
            
            const savedData = storage.getItem(this.storageKey);
            if (savedData) {
                this.data = JSON.parse(savedData);
                console.log('MBlock: Clipboard data loaded from storage');
                return true;
            }
        } catch (error) {
            console.warn('MBlock: Error loading from storage:', error);
        }
        return false;
    },
    
    // Save data to storage
    saveToStorage: function() {
        try {
            const storage = this.getStorage();
            if (!storage || !this.data) return false;
            
            storage.setItem(this.storageKey, JSON.stringify(this.data));
            console.log('MBlock: Clipboard data saved to storage');
            return true;
        } catch (error) {
            console.warn('MBlock: Error saving to storage:', error);
            return false;
        }
    },
    
    // Clear storage
    clearStorage: function() {
        try {
            const storage = this.getStorage();
            if (storage) {
                storage.removeItem(this.storageKey);
                console.log('MBlock: Clipboard storage cleared');
            }
        } catch (error) {
            console.warn('MBlock: Error clearing storage:', error);
        }
    },
    
    // Get module type for compatibility checking
    getModuleType: function(element) {
        try {
            // Try multiple methods to get module type
            const moduleAttr = element.attr('data-module-id') || element.attr('data-module') || element.data('module');
            if (moduleAttr) return moduleAttr;
            
            // Try to extract from wrapper classes or data
            const className = element.attr('class') || '';
            const classMatch = className.match(/mblock-module-(\w+)/);
            if (classMatch) return classMatch[1];
            
            // Try parent elements
            const $parent = element.closest('[data-module], [data-module-id]');
            if ($parent.length) {
                return $parent.attr('data-module') || $parent.attr('data-module-id');
            }
            
            // Fallback: use form action or page info
            const formAction = $('form').attr('action') || '';
            const moduleMatch = formAction.match(/module_id[=\/](\d+)/);
            if (moduleMatch) return 'module_' + moduleMatch[1];
            
            return 'default_module';
        } catch (error) {
            console.warn('MBlock: Error getting module type:', error);
            return 'unknown_module';
        }
    },
    
    showModuleTypeMismatchWarning: function(currentType, clipboardType) {
        // Additional user feedback for module type mismatch
        console.warn('MBlock: Module type mismatch - cannot paste from', clipboardType, 'to', currentType);
    },
    
    copy: function(element, item) {
        try {
            if (!item || !item.length) {
                console.warn('MBlock: No item to copy');
                return false;
            }
            
            // Get module type for compatibility checking
            const currentWrapper = element.closest('.mblock_wrapper');
            const moduleType = this.getModuleType(currentWrapper);
            
            console.log('MBlock: Starting copy operation for module type:', moduleType);
            
            // Clone the item for safe manipulation
            const itemClone = item.clone();
            
            // Prepare selectpicker elements for cloning
            if (typeof MBlockWidgets !== 'undefined' && MBlockWidgets.selectpicker) {
                MBlockWidgets.selectpicker.convertToPlain(itemClone);
            }
            
            // Capture current form data for complex restoration
            const formData = this.captureFormData(item);
            
            // Store clipboard data with metadata
            this.data = {
                html: itemClone.prop('outerHTML'),
                formData: formData,
                moduleType: moduleType,
                timestamp: Date.now(),
                savedAt: new Date().toLocaleString()
            };
            
            // Save to storage
            this.saveToStorage();
            
            // Update UI state
            this.updatePasteButtons();
            
            // Show user feedback
            this.showCopiedState(item);
            
            console.log('MBlock: Copy completed for module:', moduleType);
            return true;
            
        } catch (error) {
            console.error('MBlock: Error during copy:', error);
            return false;
        }
    },
    
    captureFormData: function(item) {
        const formData = {};
        
        try {
            // Basic form elements (inputs, textareas, selects)
            item.find('input, textarea, select').each(function() {
                const $el = $(this);
                const name = $el.attr('name');
                const type = $el.attr('type') || $el.prop('tagName').toLowerCase();
                
                if (!name) return;
                
                if (type === 'checkbox' || type === 'radio') {
                    formData[name] = {
                        type: 'checkbox_radio',
                        value: $el.val(),
                        checked: $el.is(':checked'),
                        defaultValue: $el.attr('value')
                    };
                } else if (type === 'select') {
                    formData[name] = {
                        type: 'select',
                        value: $el.val(),
                        html: $el.html()
                    };
                } else {
                    formData[name] = {
                        type: 'input',
                        value: $el.val(),
                        placeholder: $el.attr('placeholder') || ''
                    };
                }
            });
            
            // CKEditor content using addon fixes
            if (typeof MBlockAddonFixes !== 'undefined' && MBlockAddonFixes.ckeditor) {
                MBlockAddonFixes.ckeditor.captureContent(item, formData);
            }
            
            // REX widgets using widgets module
            if (typeof MBlockWidgets !== 'undefined') {
                if (MBlockWidgets.link) {
                    MBlockWidgets.link.captureData(item, formData);
                }
                if (MBlockWidgets.media) {
                    MBlockWidgets.media.captureData(item, formData);
                }
            }
            
            return formData;
            
        } catch (error) {
            console.error('MBlock: Error capturing form data:', error);
            return formData;
        }
    },
    
    paste: function(element, afterItem) {
        try {
            // Load fresh data from storage in case it was updated in another tab
            this.loadFromStorage();
            
            if (!this.data) {
                console.warn('MBlock: No data in clipboard');
                const message = '‚ùå ' + mblock_get_text('mblock_toast_clipboard_empty', 'No data in clipboard');
                mblock_show_message(message, 'warning', 3000);
                return false;
            }
            
            // Check module type compatibility
            const currentWrapper = element.closest('.mblock_wrapper');
            const currentModuleType = this.getModuleType(currentWrapper);
            const clipboardModuleType = this.data.moduleType || 'unknown_module';
            
            if (currentModuleType !== clipboardModuleType) {
                console.warn('MBlock: Module type mismatch. Paste aborted.', {
                    current: currentModuleType,
                    clipboard: clipboardModuleType
                });
                const message = '‚ö†Ô∏è ' + mblock_get_text('mblock_toast_module_type_mismatch', 'Module type mismatch') + ': ' + clipboardModuleType + ' ‚â† ' + currentModuleType;
                mblock_show_message(message, 'error', 4000);
                
                // Show user feedback
                this.showModuleTypeMismatchWarning(currentModuleType, clipboardModuleType);
                return false;
            }
            
            // Create element from clipboard
            const pastedItem = $(this.data.html);
            
            // Clean up IDs and names to avoid conflicts
            this.cleanupPastedItem(pastedItem);
            
            // Insert item
            if (afterItem && afterItem.length) {
                // Destroy sortable before manipulation
                if (typeof MBlockSortable !== 'undefined') {
                    MBlockSortable.destroy(element);
                }
                
                afterItem.after(pastedItem);
            } else {
                element.prepend(pastedItem);
            }
            
            // Add unique ids
            mblock_set_unique_id(pastedItem, true);
            
            // CRITICAL: Reinitialize widgets BEFORE form data restoration
            if (typeof MBlockWidgets !== 'undefined' && MBlockWidgets.reinitializeAll) {
                MBlockWidgets.reinitializeAll(pastedItem);
            }
            
            // Destroy existing CKEditor5 instances before reindexing
            if (typeof MBlockAddonFixes !== 'undefined' && MBlockAddonFixes.ckeditor) {
                MBlockAddonFixes.ckeditor.destroyInstances(pastedItem);
            }
            
            // Restore NON-CKEditor form values first
            if (this.data.formData) {
                this.restoreNonCKEditorFormData(pastedItem, this.data.formData);
            }
            
            // Reinitialize sortable
            mblock_init_sort(element);
            
            // Trigger rex:ready event for full reinitialization (including CKEditor5)
            pastedItem.trigger('rex:ready', [pastedItem]);
            
            // CRITICAL: Handle nested MBlock wrappers inside pasted content (GridBlock compatibility)
            if (typeof MBlockUtils.nested !== 'undefined') {
                MBlockUtils.nested.initializeNested(pastedItem);
            }

            // Wait for CKEditor5 initialization, then restore content
            if (this.data.formData && typeof MBlockAddonFixes !== 'undefined' && MBlockAddonFixes.ckeditor) {
                setTimeout(() => {
                    MBlockAddonFixes.ckeditor.restoreContent(pastedItem, this.data.formData);
                }, 500);
            }
            
            // Component reinitialization
            setTimeout(() => {
                // Initialize selectpicker
                if (typeof MBlockWidgets !== 'undefined' && MBlockWidgets.selectpicker) {
                    MBlockWidgets.selectpicker.initialize(pastedItem);
                }
                
                // Trigger change events
                pastedItem.find('input, select, textarea').trigger('change');
            }, 50);
            
            // Scroll to pasted item
            setTimeout(() => {
                if (pastedItem && pastedItem.length && pastedItem.is(':visible')) {
                    mblock_smooth_scroll_to_element(pastedItem[0]);
                }
            }, 100);
            
            // ‚ú® Add glow effect to pasted item using utility
            setTimeout(() => {
                if (pastedItem && pastedItem.length && pastedItem.is(':visible')) {
                    MBlockUtils.animation.addGlowEffect(pastedItem, 'mblock-paste-glow', 1200);
                    
                    // Centralized success feedback (uses BLOECKS when available, otherwise MBLOCK fallback)
                    const message = '‚úÖ ' + mblock_get_text('mblock_toast_paste_success', 'Block successfully pasted!');
                    mblock_show_message(message, 'success', 4000);
                }
            }, 150);
            
            return true;
            
        } catch (error) {
            console.error('MBlock: Error during paste:', error);
            return false;
        }
    },
    
    cleanupPastedItem: function(item) {
        try {
            // Remove mblock-specific data attributes
            item.removeAttr('data-mblock_index');
            
            // Clean form elements
            item.find('input, textarea, select').each(function() {
                const $el = $(this);
                const name = $el.attr('name');
                if (name && name.indexOf('mblock_new_') === -1) {
                    $el.attr('name', 'mblock_new_' + name);
                }
                
                // DON'T clear values here - they will be restored later by restoreComplexFormData
                // Only clear specific input types that should always be empty
                const inputType = $el.attr('type');
                if (inputType === 'file') {
                    $el.val(''); // File inputs should always be cleared
                }
                
                // Keep unique values for unique fields
                if ($el.attr('data-unique') && !$el.val()) {
                    // Only generate unique value if field is empty
                    const unique_id = Math.random().toString(16).slice(2);
                    $el.val(unique_id);
                }
            });
            
            // Clean IDs that might cause conflicts
            item.find('[id]').each(function() {
                const $el = $(this);
                const id = $el.attr('id');
                // Keep CKEditor and REX widget IDs - they need proper reindexing
                if (id && !id.match(/^(REX_|ck)/)) {
                    $el.removeAttr('id');
                }
            });
            
        } catch (error) {
            console.error('MBlock: Error cleaning up pasted item:', error);
        }
    },

    restoreNonCKEditorFormData: function(pastedItem, formData) {
        try {
            Object.keys(formData).forEach(originalName => {
                const fieldData = formData[originalName];
                
                if (!fieldData || typeof fieldData !== 'object') return;
                if (fieldData.type === 'ckeditor') return; // Skip CKEditor fields
                
                // Find field by smart matching
                let $field = pastedItem.find(`[name="${originalName}"], [name="mblock_new_${originalName}"]`);
                
                if (!$field.length) {
                    return;
                }
                
                // Handle different field types (except ckeditor)
                this.restoreFieldData($field, fieldData, pastedItem, originalName);
            });
        } catch (error) {
            console.error('MBlock: Error restoring non-CKEditor data:', error);
        }
    },

    restoreFieldData: function($field, fieldData, pastedItem, originalName) {
        // Handle different field types
        switch (fieldData.type) {
            case 'checkbox_radio':
                $field.val(fieldData.value);
                $field.prop('checked', fieldData.checked);
                if (fieldData.defaultValue) {
                    $field.attr('value', fieldData.defaultValue);
                }
                break;
                
            case 'select':
                // Restore select HTML if needed
                if (fieldData.html) {
                    $field.html(fieldData.html);
                }
                $field.val(fieldData.value);
                break;
                
            case 'rex_link':
                if (typeof MBlockWidgets !== 'undefined' && MBlockWidgets.link) {
                    MBlockWidgets.link.restoreData(pastedItem, fieldData, $field);
                }
                break;
                
            case 'rex_media':
                if (typeof MBlockWidgets !== 'undefined' && MBlockWidgets.media) {
                    MBlockWidgets.media.restoreData(pastedItem, fieldData, $field);
                }
                break;
                
            default:
                // Handle regular input fields
                if (fieldData.value !== undefined) {
                    $field.val(fieldData.value);
                    if (fieldData.placeholder) {
                        $field.attr('placeholder', fieldData.placeholder);
                    }
                }
                break;
        }
    },
    
    showCopiedState: function(item) {
        // Visual feedback using centralized animation utility
        MBlockUtils.animation.addGlowEffect(item, 'mblock-copy-glow', 1000);
        
        // Centralized copy feedback
        const copyMessage = 'üìã ' + mblock_get_text('mblock_toast_copy_success', 'Block successfully copied!');
        mblock_show_message(copyMessage, 'success', 3000);
            
        // Optional: Also give feedback to the copy button if it exists
        const $copyBtn = item.find('.mblock-copy-btn');
        if ($copyBtn.length) {
            MBlockUtils.animation.addGlowEffect($copyBtn, 'is-copied', 1000);
        }
    },
    
    updatePasteButtons: function() {
        const hasData = !!this.data;
        
        if (hasData) {
            // Check module compatibility for all visible MBlock wrappers
            $('.mblock_wrapper').each((index, wrapperElement) => {
                const $wrapper = $(wrapperElement);
                const currentModuleType = this.getModuleType($wrapper);
                const clipboardModuleType = this.data.moduleType || 'unknown_module';
                
                // Find paste buttons in this wrapper
                const $pasteButtons = $wrapper.find('.mblock-paste-btn');
                
                if (currentModuleType === clipboardModuleType) {
                    // Module compatible - enable buttons
                    $pasteButtons.removeClass('disabled').prop('disabled', false);
                    $pasteButtons.attr('title', 'Paste element (Module compatible)');
                } else {
                    // Module not compatible - disable buttons
                    $pasteButtons.addClass('disabled').prop('disabled', true);
                    $pasteButtons.attr('title', `Cannot paste: Different module type (Current: ${currentModuleType}, Clipboard: ${clipboardModuleType})`);
                }
            });
        } else {
            // No data - disable all buttons
            $('.mblock-paste-btn').addClass('disabled').prop('disabled', true);
            $('.mblock-paste-btn').attr('title', 'No data in clipboard');
        }
        
        // Update toolbar visibility
        const toolbar = $('.mblock-copy-paste-toolbar');
        if (hasData) {
            toolbar.show();
        } else {
            toolbar.hide();
        }
        
        // Update button text with storage info  
        const storageInfo = this.useSessionStorage ? 'Session' : 'Local';
    },
    
    clear: function() {
        this.data = null;
        this.clearStorage();
        this.updatePasteButtons();
    },
    
    // Get clipboard info for debugging
    getInfo: function() {
        return {
            hasData: !!this.data,
            storageMode: this.useSessionStorage ? 'Session' : 'Local',
            timestamp: this.data ? this.data.timestamp : null,
            savedAt: this.data ? this.data.savedAt : null,
            itemCount: this.data && this.data.formData ? Object.keys(this.data.formData).length : 0
        };
    }
};

// Online/Offline Toggle functionality
var MBlockOnlineToggle = {
    
    toggle: function(element, item) {
        try {
            if (!item || !item.length) {
                console.warn('MBlock: No item found for Online/Offline Toggle');
                return false;
            }
            
            const isOnline = !item.hasClass('mblock-offline');
            const $toggleBtn = item.find('.mblock-online-toggle');
            const $icon = $toggleBtn.find('i');
            
            if (isOnline) {
                // Set to offline
                item.addClass('mblock-offline');
                $toggleBtn.removeClass('btn-online').addClass('btn-offline')
                    .attr('title', 'Set online');
                
                // Change icon
                if ($icon.length) {
                    $icon.removeClass('rex-icon-online').addClass('rex-icon-offline');
                } else {
                    $toggleBtn.html('<i class="rex-icon rex-icon-offline"></i>');
                }
                
                // Add hidden input to store offline state
                this.setOfflineState(item, true);
                
            } else {
                // Set to online
                item.removeClass('mblock-offline');
                $toggleBtn.removeClass('btn-offline').addClass('btn-online')
                    .attr('title', 'Set offline');
                
                // Change icon
                if ($icon.length) {
                    $icon.removeClass('rex-icon-offline').addClass('rex-icon-online');
                } else {
                    $toggleBtn.html('<i class="rex-icon rex-icon-online"></i>');
                }
                
                // Remove offline state
                this.setOfflineState(item, false);
                
            }
            
            return true;
            
        } catch (error) {
            console.error('MBlock: Error in Online/Offline Toggle:', error);
            return false;
        }
    },
    
    setOfflineState: function(item, isOffline) {
        try {
            // Look for existing mblock_offline input (must be defined in template)
            const $offlineInput = item.find('input[name*="mblock_offline"]');
            
            if ($offlineInput.length) {
                // Simply set the value - field already exists in template
                $offlineInput.val(isOffline ? '1' : '0');
            } else {
                console.warn('MBlock: No mblock_offline input found - must be defined in template for this functionality');
            }
            
        } catch (error) {
            console.error('MBlock: Error setting offline status:', error);
        }
    },
    
    initializeStates: function(element) {
        try {
            // Initialize toggle buttons based on existing offline states
            element.find('> div.sortitem').each(function(index) {
                const $item = $(this);
                const itemIndex = $item.attr('data-mblock_index') || index;
                
                // Look for offline input with multiple strategies
                let $offlineInput = $item.find('input[name*="mblock_offline"]');
                
                // Fallback: try different name patterns
                if (!$offlineInput.length) {
                    $offlineInput = $item.find('input[name*="_offline"]');
                }
                if (!$offlineInput.length) {
                    $offlineInput = $item.find('input[value="1"][type="hidden"]');
                }
                
                const $toggleBtn = $item.find('.mblock-online-toggle');
                const $icon = $toggleBtn.find('i');
                
                if ($toggleBtn.length) {
                    const isOffline = $offlineInput.length && ($offlineInput.val() === '1' || $offlineInput.val() === 1);
                    
                    if (isOffline) {
                        // Item is offline
                        $item.addClass('mblock-offline');
                        $toggleBtn.removeClass('btn-online').addClass('btn-offline')
                            .attr('title', 'Set online');
                        
                        if ($icon.length) {
                            $icon.removeClass('rex-icon-online').addClass('rex-icon-offline');
                        } else {
                            $toggleBtn.html('<i class="rex-icon rex-icon-offline"></i>');
                        }
                    } else {
                        // Item is online (value is 0, empty, or input doesn't exist)
                        $item.removeClass('mblock-offline');
                        $toggleBtn.removeClass('btn-offline').addClass('btn-online')
                            .attr('title', 'Set offline');
                        
                        if ($icon.length) {
                            $icon.removeClass('rex-icon-offline').addClass('rex-icon-online');
                        } else {
                            $toggleBtn.html('<i class="rex-icon rex-icon-online"></i>');
                        }
                    }
                }
            });
            
        } catch (error) {
            console.error('MBlock: Error initializing Online/Offline states:', error);
        }
    },

    // New method for auto-detected offline toggle buttons
    toggleAutoDetected: function(element, item, button) {
        try {
            if (!item || !item.length || !button || !button.length) {
                console.warn('MBlock: No item or button found for Auto-Detected Toggle');
                return false;
            }
            
            // Get current offline status from button data attribute
            const currentIsOffline = button.attr('data-offline') === '1';
            const newIsOffline = !currentIsOffline;
            
            // Find the corresponding mblock_offline input field
            const $offlineInput = item.find('input[name*="mblock_offline"]');
            
            if (!$offlineInput.length) {
                console.warn('MBlock: No mblock_offline input field found in item');
                return false;
            }
            
            // Update the input value
            $offlineInput.val(newIsOffline ? '1' : '0');
            
            // Update button appearance with improved colors
            const buttonClass = newIsOffline ? 'btn-danger' : 'btn-success'; // Red for offline, green for online
            const iconClass = newIsOffline ? 'rex-icon-offline' : 'rex-icon-online';
            const buttonTitle = newIsOffline ? 'Set online' : 'Set offline';
            const buttonText = newIsOffline ? 'Offline' : 'Online';
            
            // Update button attributes and classes
            button.removeClass('btn-default btn-warning btn-success btn-danger')
                  .addClass(buttonClass)
                  .attr('title', buttonTitle)
                  .attr('data-offline', newIsOffline ? '1' : '0');
            
            // Update icon and text
            const $icon = button.find('i');
            if ($icon.length) {
                $icon.removeClass('rex-icon-online rex-icon-offline')
                     .addClass(iconClass);
            }
            
            // Update button text
            const textContent = button.html().replace(/Offline|Online/, buttonText);
            button.html(textContent);
            
            // Update item CSS class
            if (newIsOffline) {
                item.addClass('mblock-offline');
            } else {
                item.removeClass('mblock-offline');
            }
                       
            return true;
            
        } catch (error) {
            console.error('MBlock: Error in Auto-Detected Toggle:', error);
            return false;
        }
    }
};

// Toolbar initialization with better modular structure
function mblock_init_toolbar(element) {
    try {
        // Only initialize if Copy/Paste is enabled
        if (!checkCopyPasteEnabled()) {
            return;
        }
        
        // Centralized toolbar event configuration
        const toolbarEvents = [
            {
                selector: '.mblock-copy-paste-toolbar .mblock-paste-btn',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        const $this = $(this);
                        if (!MBlockUtils.state.isDisabled($this)) {
                            if (typeof MBlockClipboard !== 'undefined') {
                                MBlockClipboard.paste(element, false); // false = insert at beginning
                            }
                        }
                    } catch (error) {
                        console.error('MBlock: Error in toolbar paste click handler:', error);
                    }
                    return false;
                }
            },
            {
                selector: '.mblock-copy-paste-toolbar .mblock-clear-clipboard',
                handler: function (e) {
                    e.preventDefault();
                    try {
                        if (typeof MBlockClipboard !== 'undefined') {
                            MBlockClipboard.clear();
                        }
                    } catch (error) {
                        console.error('MBlock: Error in clear clipboard click handler:', error);
                    }
                    return false;
                }
            }
        ];

        // Bind all toolbar events
        toolbarEvents.forEach(({selector, handler}) => {
            const elements = MBlockUtils.dom.findElement(element, selector);
            MBlockUtils.events.bindSafe(elements, 'click', handler);
        });
            
    } catch (error) {
        console.error('MBlock: Error in mblock_init_toolbar:', error);
    }
}

// Export for module systems (if used)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { MBlockClipboard, MBlockOnlineToggle };
}

